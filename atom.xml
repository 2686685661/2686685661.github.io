<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>如是说</title>
  
  <subtitle>李闪磊的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mrblog.lishanlei.cn/"/>
  <updated>2019-09-22T04:43:35.322Z</updated>
  <id>http://mrblog.lishanlei.cn/</id>
  
  <author>
    <name>如是说</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c++和PHP的面试题总结</title>
    <link href="http://mrblog.lishanlei.cn/2019/09/22/c-%E5%92%8CPHP%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://mrblog.lishanlei.cn/2019/09/22/c-和PHP的面试题总结/</id>
    <published>2019-09-21T16:50:15.000Z</published>
    <updated>2019-09-22T04:43:35.322Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>[TOC]</p><h2 id="常见的排序算法"><a href="#常见的排序算法" class="headerlink" title="常见的排序算法"></a>常见的排序算法</h2><p>冒泡排序</p><blockquote><p>两两比较相邻记录的关键字，如果是反序则交换，直到没有反序的记录位置</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">    flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = arr.length - <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j - <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">        swap(arr, j - <span class="number">1</span>, j);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">  arr[i] = arr[j];</span><br><span class="line">  arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好时间复杂度：O（n）</p><p>最坏时间复杂度O（$n^2$）</p><p>平均时间复杂度：O（$n^2$）</p><p>空间复杂度：O（1）</p><p>稳定性：稳定</p><p>简单选择排序</p><blockquote><p>通过n - i次关键字之间的比较，从n - i + 1个记录中选出关键字最小的记录，并和第i 个记录交换。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> min;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    min = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[min] &gt; arr[j]) &#123;</span><br><span class="line">        min = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(min != i) &#123;</span><br><span class="line">      swap(arr, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">  arr[i] = arr[j];</span><br><span class="line">  arr[j] = tmp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好时间复杂度：O（$n^2$）</p><p>最坏时间复杂度：O（$n^2$）</p><p>平均时间复杂度：O（$n^2$）</p><p>空间复杂度：O（1）</p><p>稳定性：不稳定</p><p>直接插入排序</p><blockquote><p>将n个待排序的元素看成一个有序表和无序表，从无序表中取出一个元素将其插入到有序表的指定位置，重复n-1次完成排序</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j, tmp;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &lt; arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      tmp = arr[i];</span><br><span class="line">      <span class="keyword">for</span>(j = i + <span class="number">1</span>; arr[j] &gt; tmp; j--) &#123;</span><br><span class="line">        arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最优时间复杂度：O（<strong>$n$</strong>）</p><p>最坏时间复杂度：O（$n^2$）</p><p>平均时间复杂度：O（$n^2$）</p><p>空间复杂度：O（1）</p><p>稳定性：稳定</p><p>希尔排序</p><blockquote><p>取一个增量increment作为间隔将带排序列分为increment个子序列，距离increment的元素在同一子序列，对每一个子序列进行<code>直接插入排序</code>，然后缩小增量increment并重复上面操作，直到increment = 1</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> j, tmp, increment = arr.length;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = increment + <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[i] &lt; arr[i - increment]) &#123;</span><br><span class="line">        tmp = arr[i];</span><br><span class="line">        <span class="keyword">for</span>(j = i - increment; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &gt; tmp; j -= increment) &#123;</span><br><span class="line">          arr[j + increment] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + increment] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span>(increment &gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最优时间复杂度：O（n）</p><p>最坏时间复杂度：O（<strong>$n^2$</strong>）</p><p>平均时间复杂度：O（$n^{1.3}$）</p><p>空间复杂度：O（1）</p><p>稳定性：不稳定</p><p>归并排序</p><blockquote><p>将初始序列看作是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到n/2个长度为2或1的有序子序列，再次两两归并，直到得到一个长度为n的有序序列为止</p></blockquote><p>递归实现</p><ol><li>从上到下递归</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortUp2Down</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr == <span class="keyword">null</span> || start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  mergeSortUp2Down(arr, start, mid);</span><br><span class="line">  mergeSortUp2Down(arr, mid + <span class="number">1</span>, end);</span><br><span class="line">  merge(arr, start, mid, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">int</span> i = start;</span><br><span class="line">  <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= end) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &lt; arr[j]) &#123;</span><br><span class="line">      temp[k++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      temp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(i &lt;= mid) &#123;</span><br><span class="line">    temp[k++] = arr[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(j &lt;= end) &#123;</span><br><span class="line">    temp[k++] = arr[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    arr[start + i] = temp[i];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  temp = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>从下往上递归：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortDown2Up</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i *= <span class="number">2</span>) &#123;</span><br><span class="line">    mergeGroup(arr, arr.length, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeGroup</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> len, <span class="keyword">int</span> gap)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i + <span class="number">2</span> * gap - <span class="number">1</span> &lt; len; i += (<span class="number">2</span> * gap)) &#123;</span><br><span class="line">    merge(arr, i, i + gap - <span class="number">1</span>, i + <span class="number">2</span> * gap - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(i + gap - <span class="number">1</span> &lt; len - <span class="number">1</span>) &#123;</span><br><span class="line">    merge(arr, i, i + gap - <span class="number">1</span>, len - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortNon</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> gap = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i + gap - <span class="number">1</span> &lt; arr.length; i += (<span class="number">2</span> * gap)) &#123;</span><br><span class="line">    <span class="keyword">int</span> start = i, mid = i + gap - <span class="number">1</span>, end = i + <span class="number">2</span> * gap - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(end &gt; arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">      end = arr.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    merge(arr, start, mid, end);</span><br><span class="line">  &#125;</span><br><span class="line">  gap *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最优时间复杂度：O（$n\log_2 n$）</p><p>最坏时间复杂度：O（$n\log_2 n$）</p><p>平均时间复杂度：O（$n\log_2 n$）</p><p>空间复杂度：O（n）</p><p>稳定性：稳定</p><p>堆排序</p><blockquote><p>将待排序序列构建成一个大顶堆，将最大值(堆顶)和序列最后一个元素交换，然后对于剩余的n-1个序列重新构成一个堆，重复操作。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = arr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = len /<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    maxHeapAdjust(arr, i, len);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = len; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    swap(arr, <span class="number">0</span>, i);</span><br><span class="line">    maxHeapAdjust(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeapAdjust</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> s, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, temp = arr[s];</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">2</span> * s; i &lt;= m; i *= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i + <span class="number">1</span>] &gt; arr[i]) &#123;</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp &gt;= arr[i]) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    arr[s] = arr[i];</span><br><span class="line">    s = i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  arr[s] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最优时间复杂度：O（$n\log_2 n$）</p><p>最坏时间复杂度：O（$n\log_2 n$）</p><p>平均时间复杂度：O（$n\log_2 n$）</p><p>空间复杂度：O（1）</p><p>稳定性：不稳定</p><p>快速排序</p><blockquote><p>从数列中选取一个基数，将比基数小的放在基数前面，比基数大的摆在基数后面，该分区退出后，该基准就处于数列的中间，递归堆基数前子序列和后序列进行上述操作，完成排序</p></blockquote><ol><li>递归操作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pivot;</span><br><span class="line">  <span class="keyword">if</span>(start &lt; end) &#123;</span><br><span class="line">    pivot = Partition(arr, start, end);</span><br><span class="line">    </span><br><span class="line">    Partition(arr, start, pivot - <span class="number">1</span>);</span><br><span class="line">    Partition(arr, pivot + <span class="number">1</span>, end);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pivotkey = arr[start];</span><br><span class="line">  <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">    <span class="keyword">while</span>((start &lt; end) &amp;&amp; (arr[end] &gt;= pivotkey)) &#123;</span><br><span class="line">      end--;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, start, end);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>((start &lt; end) &amp;&amp; (arr[start] &lt;= pivotkey)) &#123;</span><br><span class="line">      start++;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, start, end);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>非递归操作</li></ol><p>用栈来保存边界值(start和end)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortNon</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] stack = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">  <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> end = arr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> pivok = Partition(arr, start, end);</span><br><span class="line">  <span class="keyword">if</span>(pivot &gt; start + <span class="number">1</span>) &#123;</span><br><span class="line">    stack[top++] = start;</span><br><span class="line">    stack[top++] = pivok - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pivok &lt; end - <span class="number">1</span>) &#123;</span><br><span class="line">    stack[top++] = pivok + <span class="number">1</span>;</span><br><span class="line">    stack[top++] = end;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(top &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    end = stack[--top];</span><br><span class="line">    start = stack[--top];</span><br><span class="line">    pivok = Partition(arr, start, end);</span><br><span class="line">    <span class="keyword">if</span>(pivok &gt; start + <span class="number">1</span>) &#123;</span><br><span class="line">      stack[top++] = start;</span><br><span class="line">      stack[top++] = pivok - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pivok &lt; end - <span class="number">1</span>) &#123;</span><br><span class="line">      stack[top++] = pivok + <span class="number">1</span>;</span><br><span class="line">      stack[top++] = end;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pivokkey = arr[start];</span><br><span class="line">  <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">    <span class="keyword">while</span>((start &lt; end) &amp;&amp; (arr[end] &gt;= pivokkey)) &#123;</span><br><span class="line">      end--;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, start, end);</span><br><span class="line">    <span class="keyword">while</span>((start &lt; end) &amp;&amp; (arr[start] &lt;= pivokkey)) &#123;</span><br><span class="line">      start++;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, start, end);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最优时间复杂度：O（$n\log_2 n$）</p><p>最坏时间复杂度：O（<strong>$n^2$</strong>）</p><p>平均时间复杂度：O（$n\log_2 n$）</p><p>空间复杂度：O（n）</p><p>稳定性：不稳定</p><h2 id="php的数据类型和数据类型内核如何实现"><a href="#php的数据类型和数据类型内核如何实现" class="headerlink" title="php的数据类型和数据类型内核如何实现"></a>php的数据类型和数据类型内核如何实现</h2><ul><li><p>基本数据类型</p><ul><li>boolean</li><li>string</li><li>integer</li><li>double</li></ul></li><li><p>复合数据类型</p><ul><li>Array</li><li>Object</li></ul></li><li><p>特殊数据类型</p><ul><li>resource（资源）</li><li>null</li></ul><p>zval结构体</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> &#123;</span></span><br><span class="line">    zend_value        value;            <span class="comment">/* value */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ZEND_ENDIAN_LOHI_4(</span><br><span class="line">                zend_uchar    type,         <span class="comment">/* active type */</span></span><br><span class="line">                zend_uchar    type_flags,</span><br><span class="line">                zend_uchar    const_flags,</span><br><span class="line">                zend_uchar    reserved)     <span class="comment">/* call info for EX(This) */</span></span><br><span class="line">        &#125; v;</span><br><span class="line">        <span class="keyword">uint32_t</span> type_info;</span><br><span class="line">    &#125; u1;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span>     var_flags;</span><br><span class="line">        <span class="keyword">uint32_t</span>     next;                 <span class="comment">/* hash collision chain */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     cache_slot;           <span class="comment">/* literal cache slot */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     lineno;               <span class="comment">/* line number (for ast nodes) */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     num_args;             <span class="comment">/* arguments number for EX(This) */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     fe_pos;               <span class="comment">/* foreach position */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     fe_iter_idx;          <span class="comment">/* foreach iterator index */</span></span><br><span class="line">    &#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>变量的值：</p><p>value存储的是变量的值。这个成员是zend_value类型的，zend_value定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> _zend_value &#123;</span><br><span class="line">    zend_long         lval;             <span class="comment">/* long value */</span></span><br><span class="line">    <span class="keyword">double</span>            dval;             <span class="comment">/* double value */</span></span><br><span class="line">    zend_refcounted  *counted;</span><br><span class="line">    zend_string      *str;</span><br><span class="line">    zend_array       *arr;</span><br><span class="line">    zend_object      *obj;</span><br><span class="line">    zend_resource    *res;</span><br><span class="line">    zend_reference   *ref;</span><br><span class="line">    zend_ast_ref     *ast;</span><br><span class="line">    zval             *zv;</span><br><span class="line">    <span class="keyword">void</span>             *ptr;</span><br><span class="line">    zend_class_entry *ce;</span><br><span class="line">    zend_function    *func;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> w1;</span><br><span class="line">        <span class="keyword">uint32_t</span> w2;</span><br><span class="line">    &#125; ww;</span><br><span class="line">&#125; zend_value;</span><br></pre></td></tr></table></figure><p>Zend_value是一个联合体，小于64位的简单类型直接存储值，对于复杂类型，存储的是指针。</p><h2 id="PHP如何与nginx通信，通信方式有什么异同"><a href="#PHP如何与nginx通信，通信方式有什么异同" class="headerlink" title="PHP如何与nginx通信，通信方式有什么异同"></a>PHP如何与nginx通信，通信方式有什么异同</h2><ul><li><p>CGI模式</p><p>CGI是HTTP服务器与机器上的其他程序进行通信的一个接口。Webserver接受客户端的HTTP请求，然后建立进程执行CGI程序，客户端的请求被传递给CGI程序，CGI执行后结果再返回Webserver。</p><p>局限性：每次一个请求都要创建一个新的CGI进程</p></li><li><p>FastCGI</p><p>FastCGI是一个常驻型的CGI。</p><ol><li>Web Server 启动时载入FastCGI进程管理器</li><li>FastCGI进程管理器自身初始化，启动多个CGI解释器进程</li><li>FastCGI进程管理器选择并连接到一个CGI解释器</li><li>FastCGI子进程接着等待并处理来自FastCGI进程管理器</li></ol></li><li><p>Apache 模块</p><p>MPM用于定义apache在响应多个用户请求时所工作的模型，有三种MPM模式：</p><ol><li>prefork（一个请求一个进程响应）</li><li>worker（一个请求用一个线程响应，启动多个进程每个进程生成多个线程）</li><li>event（一个进程处理多个请求）</li></ol><p>Worker特别多的线程采用keep-alive,会导致高并发场景下无可用线程；</p><p>event使用了一个专门的线程来处理keep-alive类线程，较好的解决了上面的问题</p></li><li><p>Nginx</p><p>nginx处理php文件，只有fastcgi模式，但是链接fastcgi的方式有2种：</p><ol><li>tcp</li><li>Unix domain sockets</li></ol></li></ul><h2 id="PHP的运行模式"><a href="#PHP的运行模式" class="headerlink" title="PHP的运行模式"></a>PHP的运行模式</h2><p>1）CGI（通用网关接口/ Common Gateway Interface）<br> 2）FastCGI（常驻型CGI / Long-Live CGI）<br> 3）CLI（命令行运行 / Command Line Interface）<br> 4）Web模块模式（Apache等Web服务器运行的模式）<br> 5）ISAPI（Internet Server Application Program Interface）</p><p>PS：在PHP5.3以后，PHP不再有ISAPI模式</p><h2 id="PHP代码的执行流程"><a href="#PHP代码的执行流程" class="headerlink" title="PHP代码的执行流程"></a>PHP代码的执行流程</h2><ol><li>Scanning(Lexing)，将php代码转换为语言片段(Tokens)</li><li>Parsing，将Tokens转换成简单而有意义的表达式</li><li>Compilation，将表达式编译成Opocdes</li><li>Execution，顺次执行Opcodes，每次一条，从而实现php脚本的功能</li></ol><p><a href="http://blog.csdn.net/a2534725767/article/details/55194582" target="_blank" rel="noopener">http://blog.csdn.net/a2534725767/article/details/55194582</a></p><h2 id="PHP和Glang的区别"><a href="#PHP和Glang的区别" class="headerlink" title="PHP和Glang的区别"></a>PHP和Glang的区别</h2><p>php</p><p>优点：</p><ol><li>跨平台，性能优越</li><li>语法简单，容易上手</li><li>目前的主流技术都支持</li><li>比较完整的支持和成熟的框架</li></ol><p>缺点：</p><pre><code>1. 函数明明不规范，驼峰法和下划线，传参位置不一 2. 单线程 3. 核心异步网络不支持 4. php解释机制使每个php页面被解释后，相关资源都会被回收</code></pre><p>go</p><p>优点：</p><ol><li>go的垃圾回收机制比起c/c++全手动内存管理来说，更适合编程</li><li>同步方式可以轻松实现高并发</li><li>代码简洁，格式统一，阅读方便</li><li>性能强尽且开发效率高</li><li>可直接编译成机器码，不依赖其他库</li></ol><p>缺点：</p><ol><li>孱弱的对象体系</li><li>缺乏泛型和元编程能力</li><li>工具链不成熟</li></ol><h2 id="深度优先遍历与广度优先遍历"><a href="#深度优先遍历与广度优先遍历" class="headerlink" title="深度优先遍历与广度优先遍历"></a>深度优先遍历与广度优先遍历</h2><p><a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/18/2596983.html" target="_blank" rel="noopener">https://www.cnblogs.com/biyeymyhjob/archive/2012/07/18/2596983.html</a></p><h2 id="解释三次握手和四次挥手"><a href="#解释三次握手和四次挥手" class="headerlink" title="解释三次握手和四次挥手"></a>解释三次握手和四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>第一次握手：建立连接时，客户端发送<code>SYN=j</code>到服务器，同时进入<code>SYN_SENT</code>状态，等待服务器的确认.</p><p>第二次握手：服务器收到<code>SYN</code>包，必须确认客户的<code>SYN</code>，确认成功后向客户端发送含有<code>SYN=k;ack=j+1</code>，此时服务器进入<code>SYN_RECV</code>状态</p><p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕后，客户端和服务器进入<code>ESTABLISHED</code>状态，完成三次握手。</p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>第一次挥手：客户端发出连接释放报文，并停止发送数据。释放数据报文首部，FIN=1，其序列号为<code>seq=u</code>，客户端进入<code>FIN-WAIT-1</code>状态</p><p>第二次挥手：服务器收到连接释放报文，发出确认报文，发出确认报文，ACK=1，ack=u+1，并带上自己的序列号seq=v，此时服务端进入<code>CLOSE-WAIT</code>状态。这时客户端到服务器方向就释放了。</p><p>客户端收到服务器确认请求后，此时客户端进入<code>FIN-WAIT-2</code>状态，等待服务器发送连接释放报文。</p><p>第三次挥手：服务器向客户端发送连接释放报文，FIN=1，ack=u+1，序列号seq=w，此时服务器进入<code>LAST-ACK</code>状态，等待客户端确认</p><p>第四次挥手：客户端收到服务器的连接释放报文后，发出确认，ACK=1，ack=w+1，序列号为seq=u+1，此时客户端就进入了<code>TIME_WAIT</code>状态。这时TCP连接还没有释放，必须经过2*MSL(最长报文段寿命)时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p><p>服务器只要收到了客户端发出的确认，立即进入CLOSED状态，同样撤销TCB后，就结束这次TCP连接。</p><h2 id="为什么连接的时候是三次握手，关闭的时候确实四次挥手？"><a href="#为什么连接的时候是三次握手，关闭的时候确实四次挥手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候确实四次挥手？"></a>为什么连接的时候是三次握手，关闭的时候确实四次挥手？</h2><p>当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文，其中ACK报文是用来应答的，SYN是用来同步的。但是关闭连接时候，当服务端收到FIN报文，很可能不会立即关闭socket，所以只会先回复一个ack报文，所以需要四步挥手。</p><h2 id="为什么TIME-WAIT状态需要经过2MSL才能返回CLOSE状态"><a href="#为什么TIME-WAIT状态需要经过2MSL才能返回CLOSE状态" class="headerlink" title="为什么TIME_WAIT状态需要经过2MSL才能返回CLOSE状态"></a>为什么TIME_WAIT状态需要经过2MSL才能返回CLOSE状态</h2><p>网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL</p><h2 id="为什么不能用两次握手进行连接"><a href="#为什么不能用两次握手进行连接" class="headerlink" title="为什么不能用两次握手进行连接"></a>为什么不能用两次握手进行连接</h2><h2 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2><p>TCP设有一个保活计时器，服务器没收到一次客户端的请求后都会重新复位这个计时器，通常是两个小时，如果指定时间后没收到客户端的任何数据，服务器就发送一个探测报文段，以后每隔75秒发送一次，如果一连发送10个探测报文还没有反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><h2 id="hash解决冲突的方法"><a href="#hash解决冲突的方法" class="headerlink" title="hash解决冲突的方法"></a>hash解决冲突的方法</h2><ul><li>开放定址法</li></ul><p>$H_i$=(H(key) +$d_i$) MOD m i=1,2,3,…,s</p><p>对增量<strong>$d_i$</strong>有三种取法：</p><ul><li><p>线性探测：$d_i$=1,2,3,4,…,m-1</p></li><li><p>平方探测：$1^2$,$-1^2$,$2^2$,$-2^2$,….,$k^2$,$-k^2$</p></li><li>随机探测：$d_i$是一组伪随机数列</li></ul><ul><li>链地址法</li></ul><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><ol><li><p>指针是一个变量，只不过这个变量存储的是一个地址，指向内存中的一个存储单元；而引用和原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。</p></li><li><p>指针可以有多级，但是引用只有一级</p></li><li>指针的值可以为空，但是引用的值不能为null，并且引用在定义的时候必须初始化</li><li>指针的值可以在初始化后可以改变，即指向其他的存储单元，而引用在初始化后就不会改变了。</li><li>“sizeof引用”得到的是所指向的变量大小，而”sizeof指针”得到的是指针本身的大小</li><li>指针和引用的自增运算意义不一样</li></ol><h2 id="比较两棵树是否相同"><a href="#比较两棵树是否相同" class="headerlink" title="比较两棵树是否相同"></a>比较两棵树是否相同</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode node1, TreeNode node2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(node1 == <span class="keyword">null</span> &amp;&amp; node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(node1 != <span class="keyword">null</span> &amp; node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node1.val != node2.val) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> isSameTree(node1.left, node2.left) &amp;&amp; isSameTree(node1.right, node2.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">    swap(arr, arr[i], arr[n - i - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  String.valueOf(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>一种提高内存访问速度的策略，cpu在访问未对其的内存需要经过两次内存访问，而经过内存对齐一次就可以了。</p><p>数据类型长度和数据成员对齐：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char 1</span><br><span class="line">short 2</span><br><span class="line">int 4</span><br><span class="line">long 64bit 8 32bit 4</span><br><span class="line">double 8</span><br><span class="line">* 64bit 8 32bit 4</span><br></pre></td></tr></table></figure><p>对齐规则：</p><ul><li><p><strong>原则一:存放的首地址偏移量 %  min(当前类型大小,对齐系数) == 0</strong></p></li><li><p>结构体整体对齐，也称作二次对齐，结构体整体大小 % min(当前类型最大的大小，对齐系数) == 0</p></li></ul><h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><blockquote><p>一个数列ai如果满足条件a1 &lt; a2 &lt; … &lt; aN，那么它是一个有序的上升数列。我们取数列(a1, a2, …, aN)的任一子序列(ai1, ai2, …, aiK)使得1 &lt;= i1 &lt; i2&lt; … &lt; iK &lt;= N。例如，数列(1, 7, 3, 5, 9, 4, 8)的有序上升子序列，像(1, 7)， (3, 4, 8)和许多其他的子序列。在所有的子序列中，最长的上升子序列的长度是4，如(1, 3, 5, 8)。现在你要写一个程序，从给出的数列中找到它的最长上升子序列。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxLongSubSeq</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span> [arr.length];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    dp[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[i] &gt; arr[j] &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i]) &#123;</span><br><span class="line">        dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    result = Math.max(result, dp[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PHP在内存中的分配（堆和栈的区别）"><a href="#PHP在内存中的分配（堆和栈的区别）" class="headerlink" title="PHP在内存中的分配（堆和栈的区别）"></a>PHP在内存中的分配（堆和栈的区别）</h2><ul><li><p>初始化静态常量段</p><p>存放程序中以初始化且不为0的全局变量。如静态变量和常量</p></li><li><p>代码段</p><p>存放程序执行代码的一块内存区域，比如函数和方法</p></li><li><p>栈空间段</p><p>存储占用相同空间长度并且占用空间小的数据类型的地方，存储的都是局部变量。栈中变量可以手动释放，</p></li><li><p>堆内存段</p><p>在堆内存中是不可以直接存取的内存，存储的是数组和对象，堆不会随时释放，但是会被当成垃圾，最后铜鼓后垃圾回收机制去实现垃圾回收</p></li></ul><h2 id="PHP的内存分配理解"><a href="#PHP的内存分配理解" class="headerlink" title="PHP的内存分配理解"></a>PHP的内存分配理解</h2><p>PHP脚本使用新的内存时，会向OS申请一大块内存（ZEND_MM_SEG_SIZE=256K），然后分配给你需要的一块小内存。</p><p>当释放这块小内存，php不会返还给OS，而是<code>保留下来给后续处理使用</code>。如果存在后续逻辑请求内存导致申请的大块内存已经分光，这时才会向OS申请一块新的内存。</p><p>相关API：</p><p><img src="https://images2015.cnblogs.com/blog/798267/201601/798267-20160125092645145-1991624700.png" alt="img"></p><p>防止有内存泄露并尽可能快的释放所有内存是内存管理的重要组成部分。因为安全原因，在请求结束时，Zend引擎会释放所有由上面提到的API所分配的内存。</p><h2 id="PHP数组的实现机制-Hash-Table"><a href="#PHP数组的实现机制-Hash-Table" class="headerlink" title="PHP数组的实现机制(Hash Table)"></a>PHP数组的实现机制(Hash Table)</h2><p>PHP的数组,关联数组,对象属性,函数表,符号表,等等都是用HashTable来做为容器的.</p><p> PHP使用了一些机制, 使得可以在O(1)的时间复杂度下实现数组的增删, 并同时支持线性遍历和随机访问.</p><p>Hash Table采用<code>拉链法</code>解决冲突</p><p>Hash Table结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">hashtable</span> &#123;</span></span><br><span class="line">uint nTableSize;        <span class="comment">/* 散列表大小, Hash值的区间 */</span></span><br><span class="line">uint nTableMask;        <span class="comment">/* 等于nTableSize -1, 用于快速定位 */</span></span><br><span class="line">uint nNumOfElements;    <span class="comment">/* HashTable中实际元素的个数 */</span></span><br><span class="line">ulong nNextFreeElement; <span class="comment">/* 下个空闲可用位置的数字索引 */</span></span><br><span class="line">Bucket *pInternalPointer;   <span class="comment">/* 内部位置指针, 会被reset, current这些遍历函数使用 */</span></span><br><span class="line">Bucket *pListHead;      <span class="comment">/* 头元素, 用于线性遍历 */</span></span><br><span class="line">Bucket *pListTail;      <span class="comment">/* 尾元素, 用于线性遍历 */</span></span><br><span class="line">Bucket **arBuckets;     <span class="comment">/* 实际的存储容器 */</span></span><br><span class="line"><span class="keyword">dtor_func_t</span> pDestructor;<span class="comment">/* 元素的析构函数(指针) */</span></span><br><span class="line">zend_bool persistent;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> nApplyCount; <span class="comment">/* 循环遍历保护 */</span></span><br><span class="line">zend_bool bApplyProtection;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ZEND_DEBUG</span></span><br><span class="line"><span class="keyword">int</span> inconsistent;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; HashTable;</span><br></pre></td></tr></table></figure><p>对于Hash Table来说，其关键元素是<code>arBuckets</code>，这是实际存储的容器，结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> &#123;</span></span><br><span class="line">ulong h;                        <span class="comment">/* 数字索引/hash值 */</span></span><br><span class="line">uint nKeyLength;                <span class="comment">/* 字符索引的长度 */</span></span><br><span class="line"><span class="keyword">void</span> *pData;                    <span class="comment">/* 数据 */</span></span><br><span class="line"><span class="keyword">void</span> *pDataPtr;                 <span class="comment">/* 数据指针 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">pListNext</span>;</span>               <span class="comment">/* 下一个元素, 用于线性遍历 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">pListLast</span>;</span>       <span class="comment">/* 上一个元素, 用于线性遍历 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">pNext</span>;</span>                   <span class="comment">/* 处于同一个拉链中的下一个元素 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> *<span class="title">pLast</span>;</span>                   <span class="comment">/* 处于同一拉链中的上一个元素 */</span></span><br><span class="line"><span class="keyword">char</span> arKey[<span class="number">1</span>]; <span class="comment">/* 节省内存,方便初始化的技巧 */</span></span><br><span class="line">&#125; Bucket;</span><br></pre></td></tr></table></figure><h2 id="二叉树的深度和统计二叉树的叶子节点个数"><a href="#二叉树的深度和统计二叉树的叶子节点个数" class="headerlink" title="二叉树的深度和统计二叉树的叶子节点个数"></a>二叉树的深度和统计二叉树的叶子节点个数</h2><p>求二叉树深度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">biTreeDepth</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> l = biTreeDepth(node.left);</span><br><span class="line">    <span class="keyword">int</span> r = biTreeDepth(node.right);</span><br><span class="line">    <span class="keyword">return</span> l &gt; r ? l + <span class="number">1</span> : r + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>统计二叉树的叶节点个数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">biTreeNodeCount</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> l = biTreeNodeCount(node.left);</span><br><span class="line">    <span class="keyword">int</span> r = biTreeNodeCount(node.right);</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="number">0</span> &amp;&amp; r == <span class="number">0</span>) <span class="number">1</span> : l+ r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><p>方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">  ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">  <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span> || size &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(size &gt;= arr.length) &#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[i] &gt; max) &#123;</span><br><span class="line">        max = arr[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(max);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = size - <span class="number">1</span>, max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; arr.length) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> r = i; r &lt;= j; r++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[r] &gt; max) &#123;</span><br><span class="line">          max = arr[r];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      list.add(max);</span><br><span class="line">      max = Integer.MIN_VALUE;</span><br><span class="line">      i++;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的非递归遍历"><a href="#二叉树的非递归遍历" class="headerlink" title="二叉树的非递归遍历"></a>二叉树的非递归遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">  <span class="keyword">public</span> Node left;</span><br><span class="line">  <span class="keyword">public</span> Node right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先序遍历</p><ul><li><p>先将根结点加入栈</p></li><li><p>访问根结点</p></li><li><p>如果根结点存在<code>右孩子</code>，将右孩子加入栈中</p></li><li><p>如果根结点存在<code>左孩子</code>，将左孩子加入栈中</p></li><li><p>重复上面</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  Node temp = root;</span><br><span class="line">  Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">  stack.push(root);</span><br><span class="line">  <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">    Node p = stack.pop();</span><br><span class="line">    System.out.println(p.val);</span><br><span class="line">    <span class="keyword">if</span>(p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stack.push(p.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stack.push(p.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历</p><ol><li><p>现将根结点加入栈中</p></li><li><p>将当前节点的所有左孩子入栈，直到左孩子为空</p></li><li><p>访问栈顶元素，如果栈顶元素存在右孩子，则继续执行第二步</p></li><li><p>重复2，3步，直到栈为空且所有节点都被访问</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  Node temp = root;</span><br><span class="line">  Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">  <span class="keyword">while</span>(temp != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stack.push(temp);</span><br><span class="line">      temp = temp.left;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = stack.pop();</span><br><span class="line">    System.out.println(temp.val);</span><br><span class="line">    <span class="comment">//如果栈顶元素存在右孩子，则将右孩子赋值给tmp，也就是将右孩子入栈</span></span><br><span class="line">    <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">      temp = temp.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则，将tmp置为null，表示下次要访问的是栈顶元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      temp = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序列遍历</p><ul><li><p>根结点入栈</p></li><li><p>将根结点的<code>左子树</code>入栈，直到没有左子树为止</p></li><li><p>得到栈顶元素值，先不访问，判断栈顶元素是否存在右孩子，如果存在并且没有访问，则将右孩子入栈；否则就访问栈顶元素</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  Node temp = root;</span><br><span class="line">  Node prev = <span class="keyword">null</span>;</span><br><span class="line">  Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">  <span class="keyword">while</span>(temp != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stack.push(temp);</span><br><span class="line">      temp = temp.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!stack.isEmpty()) &#123;</span><br><span class="line">      temp = stack.peek();</span><br><span class="line">      <span class="comment">//没有右孩子，或者右孩子已经被访问过</span></span><br><span class="line">      <span class="keyword">if</span>(temp.right == <span class="keyword">null</span> || temp.right == prev) &#123;</span><br><span class="line">        temp = stack.pop();</span><br><span class="line">        System.out.println(temp.val);</span><br><span class="line">        prev = temp;</span><br><span class="line">        temp = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//存在没有被访问的右孩子</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        temp = temp.right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">  <span class="keyword">public</span> ListNode next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  ListNode temp = head.next;</span><br><span class="line">  ListNode newHead = reverse(head.next);</span><br><span class="line">  temp.next = head;</span><br><span class="line">  head.next = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseNon</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">  ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">  ListNode next = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">    next = head.next;</span><br><span class="line">    head.next = pre;</span><br><span class="line">    pre = head;</span><br><span class="line">    head = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PHP的垃圾回收机制"><a href="#PHP的垃圾回收机制" class="headerlink" title="PHP的垃圾回收机制"></a>PHP的垃圾回收机制</h2><p>php中因为外部引用中断而不能使用的变量称为垃圾，称为”循环引用”。</p><p>为了清理垃圾，有两个准则：</p><ul><li><p>如果引用计数减少到0，所在的变量容器被清除，不属于垃圾</p></li><li><p>如果zval的引用计数减少后还大于0，它会进入<code>垃圾周期</code>。在一个垃圾周期中通过检查引用计数是否减1，且检查哪些变量容器的引用次数是零，来发现哪部分是垃圾。</p></li></ul><p>两部分：</p><ul><li><p>垃圾收集器</p><p>把变量的 <code>zend_refcount&gt;0</code>的变量 放在回收池中。当回收池的值达到一定额度了，会进行统一遍历处理。进行模拟删除，如果<code>zend_refcount=0</code>那就认为是垃圾，直接删除它</p></li><li><p>垃圾回收算法</p><p>遍历回收池中的每一个变量，根据每一个变量，再遍历每一个成员，如果成员还有嵌套的话继续遍历。然后把所有成员的 做模拟的 refcount -1。如果此时外部的变量的 引用次数为 0 。那么可以视为垃圾进行清除。如果大于0，那么恢复引用次数，并从垃圾回收池中取出。</p></li></ul><p>垃圾回收的实现方式(四色标记法)：</p><ol><li>将可能根放在根缓冲区，用<code>紫色</code>标记，称为疑似垃圾</li><li>模拟删除每个紫色变量进行引用数减1，每个变量只能被模拟删除一次，模拟删除后标记为<code>灰色</code></li><li>模拟恢复每个紫色变量（条件：变量的引用数&gt;0）,恢复后变量标记为<code>黑色</code>，剩下一堆没能恢复的就是该删除的<code>蓝色</code>节点</li><li>遍历出蓝色节点，真正删除</li></ol><h2 id="给定一个字符串，找出其中不含有重复字符的-最长子串-的长度"><a href="#给定一个字符串，找出其中不含有重复字符的-最长子串-的长度" class="headerlink" title="给定一个字符串，找出其中不含有重复字符的 最长子串 的长度"></a>给定一个字符串，找出其中不含有重复字符的 最长子串 的长度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfSubstring</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> resLength = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> strLength = str.length();</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">  Hash&lt;String&gt; set = <span class="keyword">new</span> Hash&lt;String&gt;();</span><br><span class="line">  <span class="keyword">while</span>(i &lt; strLength &amp;&amp; j &lt; strLength) &#123;</span><br><span class="line">    String resstr = str.substring(j, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!set.contains(resstr)) &#123;</span><br><span class="line">      set.add(resstr);</span><br><span class="line">      j++;</span><br><span class="line">      resLength = Math.max(resLength, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      String istr = str.substring(i, <span class="number">1</span>);</span><br><span class="line">      set.remove(istr);</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> resLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="面试" scheme="http://mrblog.lishanlei.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>今日份检查</title>
    <link href="http://mrblog.lishanlei.cn/2019/08/13/%E4%BB%8A%E6%97%A5%E4%BB%BD%E6%A3%80%E6%9F%A5/"/>
    <id>http://mrblog.lishanlei.cn/2019/08/13/今日份检查/</id>
    <published>2019-08-13T09:25:21.000Z</published>
    <updated>2019-08-16T08:21:47.687Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>写到后面，我想临时改了改，本来是给宝宝道歉用的，但是我知道，其实我们之间没有什么说谁对不起谁的。</p><p>来北京的这几天，我们吵了好几顿架。初到北京，也不知道怎么了，或许是出道一个地方，难免有对未来的惶恐，毕竟人生地不熟，想到自己未来几年或者很长一段时间都是在这里打拼生活，想到自己的以后，会有很多想法。第二个可能就是这段时间太忙了，来这之后的前几天根本就没有怎么停下里，事情特别多。总之，在北京前段时间，我和宝宝之间，有了几次吵架。现在基本上安顿下来了，我也基本上过渡了。本来答应给她这份检查的，但是后来又想了想，觉得自己应该完全静下来，好好的想一想前段时间是为什么会不和，而不是只是应付。所以这两天心里也想了想。</p><p>先来说说我们吵架的原因：其实很简单，就是没有主动的把自己的事情让对方了解，或者说是了解不够。为什么这么说呢，两个人不能天天见面，每天心里都挂念着对方，每天把想对方当作是最重要的事情，肯定非常在意的。所以迫切的想知道对方在干什么，毕竟让她知道我的一举一动，才会让她放心，才会让她觉得我就在她的身边。但是纵观我初到北京这几天，我这方面做的是很差，来到这里后总是想着有什么事情要做，要去赶紧做什么事情，但是并没有及时的把自己的消息告诉她。当时想想还很可笑，觉得自己在这里累死累活的，宝宝还过来气我，觉得很不忿，但是静下心想想，她这样做还不是因为担心我，为什么不去问别人呢，我还不知足？并不是说我不在意她或者说不想给她说，其实我心里也是一直想着的，但是前段时间确实事情很多，每天感觉都有很多事情，就想赶紧整完就不用一只想了，所以一件完了就赶紧做下一件，想着到时候给她打电话或者有时间闲下来的时候在好好的给宝宝说。看起来好像没什么不对的。其实现在想想，确实有很大的问题，情侣之间没有让对方知道你的一举一动，本身对于两个人来说，就是不对的，同时如果不让对方知道你在做什么，你这段时间在忙什么，你有什么事情，又怎么能够放心呢？</p><p>还有一个问题就是，我的脾气还是臭啊，明明知道自己理亏，但是还是嘴犟，最后说到最后就吵架了，确实是我的不对，我的脾气其实从我们在一起的时候她就说了，虽然这几年好了很多，变得不会很气人了，但是还没有达到宝贝的要求。其实好几次吵架都是我的脾气惹的祸，如果那个时候不发自己的脾气，好好的解释，好好的和她说，我相信她肯定会体谅我或者原谅我，也就不会有这么多的误会和吵架的不愉快的经历了。</p><p>综上所述，我觉得我有必要做到以下几点：</p><p>首先，在以后的找工作和工作生活中，无论做什么事情，无论要去干什么，都应该及时的和宝宝说，而不是想着做完了或者等有空的时候再说。这样子宝宝每天每时每刻都能知道我在做什么，不会随便的想歪了。哪怕事情非常紧急非常突然，也要给她发个语音或者说一下，而不是说着说着就不见人影了，过了好久再回来说刚刚自己有事情。她很体贴的，不会因为自己有什么紧急的事情或者需要忙的事情而生气，但是一定得让她知道。</p><p>还有就是好好的注意注意自己的脾气，虽然这几年下来感觉自己的脾气改了很多，但是自我良好并不代表宝宝能够接受，有时候自己不经意间发个小脾气，可能会让宝宝很难受。所以自己的脾气还是需要满满修改啊。什么时候她觉得我的脾气很好了，才证明我的脾气改过来了。</p><p>还有就是嘴得软一点，别动不动就犟，明知道宝贝生气了，还是不服软，就是在哪里顶，在那里犟。刚开始觉得自己有道理，其实静下心想想，嘴犟对自己有什么好处吗，热火了她到最后还不都是发在自己身上了。多体贴体贴，多说说好话，被骂几句也没什么。</p><p>还有就是应该主动的多体贴，别因为自己事情多或者怎么着怎么着的，无论什么事情都想着宝宝，啥事情能有宝宝重要啊，除了突然的急事不做不行的，什么事情有那么急吗？这个我需要好好反思反思，就像以前每天会叫宝宝中午起床，但是来北京后因为这几天中午下午有面试，已经好几天没有叫了。所以啊，无论有什么事情，无论有多忙，都体贴体贴宝贝，多心疼心疼她。</p><p>还有，就是无论什么时候都把她放在第一位，无论自己在哪里，无论是在郑州，还是北京，无论是和谁，都把她放在心里第一位。还是和以前保持一样，哪怕之后入职了，都和所有女生保持距离，除了工作上的事情，其他的保持三不原则：不主动，不沟通，不感兴趣。天下间的女生有两种：一种是杜宝宝，另一种是其他女生。这点我是不担心的，因为心里爱着她，就觉得她是最好的，最适合自己的，无论谁，也不能改变这些。</p><p>这些是我这几天静下心来想想后总结的，可能还有什么遗漏，之后我也会不断的反思自己，保持自己的思想。其实想想，无论我现在怎么努力，怎么找工作，不都是为了以后能让她过的更好一点，更舒服一点，如果没有了她，那我现在做的这些还有什么意义呢？所以，我的所有事情都是围绕她的，对她好，才是最重要的。谁让她是你宝贝呢，自己找的祖宗，跪着也得宠完。</p><p>其实还想到一点，就是觉得自己是不是真的很直男呢？我也不是很确定，但是从宝贝小恩爱上发的链接上，总是觉得直男的特征好多都和自己符合，我也觉得有时候给宝贝说的话，办的事情，也挺傻的。就比如有时候宝宝过来闹闹我，或者和我假装发发脾气，或者说不喜欢我了要去找别的男生(她敢)，我就看不出来，然后还生气了，的确我说的话不对不好受，其实两个人争论的焦点就是她需要我，但不直说，而是期待我能够作出她想象的行为来，满意又开心，其实刚开始我是不能理解为什么要这样的，为什么有事情不能直接给我说而是期待我自己做出来呢。但是满满的，这么长时间，我也渐渐的理解了。其实恋爱的小女生就是有点小姑娘般的幼稚的，她希望我自己能做出来，能和她心里想的一样，因为这样会觉得很幸福很有爱，就好像圣诞节到了小姑娘在壁炉边默念自己的圣诞礼物，然后在一个大雪纷飞的夜晚圣诞老人骑着白色驯鹿背着一大包礼物会给小姑娘送过来一样。而我就是那个圣诞老人。</p><p>上面布拉布拉说了很多，其实还是想把自己心里想的和对宝贝的歉意表达出来，但是感觉自己的文笔有限，根本表达不清楚，只能尽力而为了。唉，矛盾都是有的，好像大部分都是我挑的头，还说了一些让宝贝很伤心的话，每次宝贝都是心疼我而自己主动的认错，但是明明都是我的问题，现在想想，那个时候为什么还不自知呢。在这里我首先要很感谢宝宝大人，明明很委屈，但是心疼我，还是自己忍气吞声，说实话我能找到你真是太走运了，又一个善解人意的你，还没天气你，这些东西要是让别人知道非得骂我。还有这是一封对宝宝的检讨，上面我提出来的，都是我这段时间花了好几天满满的考虑的，我也会认证的进行自我完善，自我批评，争取早日能够达到宝贝心中的理想水平。</p><p>还有，就是现在已经是在找工作了，就应该把自己的思想转变转变了，不能再像以前学生一样耍性而为了。而是多想想作为一个男人，如何给宝宝一个想要的生活，或者说能让她觉得未来起码长远来看，跟着我还算踏实不悔的生活。我有必要把这个考虑用一生的时间来实现。儿女情肠有，香榭宝马也应该要有。多从一个男人的角度考虑给她一个好的未来。这是我现在看中的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活" scheme="http://mrblog.lishanlei.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="情感" scheme="http://mrblog.lishanlei.cn/tags/%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>dear杜</title>
    <link href="http://mrblog.lishanlei.cn/2019/06/25/dear%E6%9D%9C/"/>
    <id>http://mrblog.lishanlei.cn/2019/06/25/dear杜/</id>
    <published>2019-06-25T04:08:49.000Z</published>
    <updated>2019-06-25T04:36:44.192Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>最傻最傻最傻的小猪头：</p><p>​        你好，我是河南科技学院信息工程学院通信工程专业的李闪磊，鉴于你对我的信，和广大人民群众的呼声，我在此对你进行回复，如果看到，尽量不要打脸。</p><p>​        首先，我要指正你，语文还是要学好的，嗯，尽量不要写错别字，你看看我，你要是能在我这封信里挑出来一个错别字，我就请你吃饭，说到做到的那种。</p><p>​        今天是我生日，唯一的遗憾就是不能和你在一起，因为我们两个苦逼的大三狗面临着考试的摧残，主要还是我面临无数门考试的洗礼。唉，不能和你在一起过，很是不满意。不过还好，你一直陪着我，所以呢，这个生日我还是非常开心，有你真好。</p><p>​        哈哈哈，你是如何在我的生日礼物当中塞了一大堆小时候玩的玩意，我都惊呆了，打开一看，我会猜到你给我的礼物是钱包，但是没想到还有一大坨不知名的东西，拿起的一瞬间我就知道是什么了。你可真是一个小机灵鬼～不过真是一个大大的惊喜，我万万没想到啊，最喜欢的是那个，就是里面有水的游戏机，我记得小时候我最喜欢玩的就是这个，但是已经好长好长时间没有玩了。嘿嘿。</p><p>​        信我是一个字一个字读的，读的时候一边傻笑着一边读。我能想像到你写这封信的时候傻乎乎一本正经的样子。我就说那天晚上你在忙什么还不给我说，哼哼，原来是在偷偷的给我写信。不过～看在你这么认真的份上，我就放过你啦～～</p><p>​        这是我们在一起的第三个年头，也是你给我过的第三个生日，每一个年头的和你的感觉都历历在目，好像昨天我们才在一起一样，眨眼就是三年，你也成了老学姐了，我也要出去工作了。不过，白驹过隙，我们好像置身于挂布当中，唯有你永恒。这是第三年，用你的话来说，三年，三十年，三百年，我都陪着你。我也听你的，想看夕阳时我们就去看夕阳，想去旅行时我们就走遍这大江南北。想陪你窝在沙发上看电影，想和你在厨房捣鼓食物(生化武器)，想陪你去游乐场坐过山车大摆锤碰碰车(你坐我看着-_-)，想为你在每天忙完给你煮一碗面，想在你学习的时候静静地坐在你身边，我想的事情太多啦，世间千万事，有你就知足，也想和你什么都不做就这样挺好。</p><p>​        哎呀，很久没有写东西了，写的很乱呢，感觉很多语句都不通顺，但是我也不想纠结读不读得懂的问题了，因为我在写这封信的时候，我就觉得，你一定可以读得懂这些文字，就像你读懂我的心一样毫不费力。我想和你有一个家，家前有土，土上可以种上花，花沿岸而盛开，迎光开出巨朵黄花，花谢结果，累累篷上，我就坐在屋檐下，看前方黄花，看身边的你。</p><p align="right" style="margin: 0;"><b>最爱你最爱你最爱你的大帅锅</b></p><br><p align="right"><b>2019/06/25</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活" scheme="http://mrblog.lishanlei.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="情感" scheme="http://mrblog.lishanlei.cn/tags/%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>一张相片引起的回忆</title>
    <link href="http://mrblog.lishanlei.cn/2019/06/05/%E4%B8%80%E5%BC%A0%E7%9B%B8%E7%89%87%E5%BC%95%E8%B5%B7%E7%9A%84%E5%9B%9E%E5%BF%86/"/>
    <id>http://mrblog.lishanlei.cn/2019/06/05/一张相片引起的回忆/</id>
    <published>2019-06-05T06:08:32.000Z</published>
    <updated>2019-06-08T04:57:58.098Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这两天挺烦躁的，我们的关系不知道怎么了，一触即炸，好像两个人都有无数的不耐烦，一点点的事情，一句小小的话好像都会挑起战争。在我写这篇文章的时候，心中还是有着些许生气。我相信那边的她也是这样的。</p><p>烦躁的无聊，中午的时候拿起了钱包，打开就看到夹在钱包中的一种老照片，说老照片，其实并不老，距今也就过去了三年，但是泛黄的底色加上无数泛起的回忆，给这张照片渲染了时光的味道。</p><p>照片很简单，初夏，北方的一座小城，我和他走在一条熟悉的街道上。照片中的她微微抬头双手遮住树荫间穿透的阳光，迈着轻快的步伐跟在我的身边，我们相隔有几十公分的距离，拘谨而又放松。这是三年前的某一天朋友为我们抓拍的，后来洗出来之后我把它做了剪裁后夹在我的钱包中。</p><p>这张照片不由分说的，将我拉进了记忆。五年前，我们是第一次相遇，彼时的她端正的坐在前排，正在和繁琐的数学证明题和头大的理科做着较量。而我只是刚刚转到这个班的插班生，无聊的趴在最后一排打着瞌睡，想着中午怎么和狐朋狗友溜出去吃饭。总之，就是在那个时候，是我人生中最重要的一次遇见，就好像留学的徐志摩在欧洲遇见了十六岁的林徽因那样，只那么一眼。</p><p>生活在北方的一座小城，彼时满脑子都是想要出去，出去，出去，只要出去，无论去哪里，除此之外，就是异性，异性，异性。我和她的遇见就是这样的，没有什么轰轰烈烈，很平淡的，就喜欢上了。</p><p>当时的我纯属愣头青，不会追女孩子，具体的就不说了，现在想一想，倒是还会几分脸红。</p><p>这个傻姑娘啊，傻傻的和我在一起三年了，还是如第一次相遇一样，傻傻的，倔倔的。一路走来，越熟悉，也不知怎么的，就越心疼她，一个什么都不知道的小姑娘，就这样把自己的爱毫无保留的交给了另外一个人。</p><p>磕磕绊绊的，就到了现在，我们有了很多新的难题，新的困境，找工作的压力，考研的压力，异地分居的压力。不断挑战着我们，也因此，生活中我们好像总是很容易吵架，也会有烦躁的心理。比如现在。</p><p>——————————————————————分割线————————————————————————</p><p>前两天去找宝贝了，现在回来，应宝宝的要求，重新写这篇文章的结尾～～</p><p>这次相见给我最大的感受就是，距离真的很恶心。其实现在我们看看前两天的事情，并不是什么很大的事情，但是正是因为我们相处两地，造成了隔阂，本应该一个拥抱就能解决的事情，却能够发展到争吵。我也懂得了很多，争吵真的不应该存在，其实之前很多次我们吵架的时候，每次想到以前的种种，还有她爱我，想到她不求回报的和我在一起，我还有什么不知足呢，我还怎么能惹她生气呢。说到底，无非就是自己做的还不够好罢了。我们定下了不再争吵。我知道，有矛盾是正常的，但是当出现矛盾的时候，我们要做的不是给对方脸色，而是尽快的到达她的身边，给她一个大大的拥抱。有什么问题不是一个拥抱不能解决的呢？如果有，那就两个拥抱。</p><p>还有还有，女生真的是越宠越可爱的。这不禁让我回忆起我们以前的样子，我在这里对你道歉宝贝。很抱歉，以前的我没有意识到这些，妥妥的一个钢铁直男，没有给你足够的温暖和宠爱。让你感到委屈和伤心。倘若能够回到过去，我一定给以前的自己一个大嘴巴子，然后告诉以前的我：”要对她好一点！”一路走来，你终于从一个独立的女生活成了我的小可爱，很庆幸，我们越来越好，也很庆幸，我意识的还不算晚。</p><p>一张照片，引起了一份回忆，这一张照片，记录了我们三年来的风风雨雨，如今，我们有了很多很多很多的照片，但是这张照片依旧静静地躺在我的钱包里。如果这张照片有了记忆，它大概会想，就让我这样一直躺下去吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="情感" scheme="http://mrblog.lishanlei.cn/categories/%E6%83%85%E6%84%9F/"/>
    
    
      <category term="随心而发" scheme="http://mrblog.lishanlei.cn/tags/%E9%9A%8F%E5%BF%83%E8%80%8C%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>给你的一封信</title>
    <link href="http://mrblog.lishanlei.cn/2019/05/10/%E7%BB%99%E4%BD%A0%E7%9A%84%E4%B8%80%E5%B0%81%E4%BF%A1/"/>
    <id>http://mrblog.lishanlei.cn/2019/05/10/给你的一封信/</id>
    <published>2019-05-10T06:39:57.000Z</published>
    <updated>2019-06-25T04:35:52.381Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>    <div id="aplayer-LGlNHxgB" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="553755659" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><p><br></p><p>YDear 宝贝：</p><p>&emsp;&emsp;你好啊亲爱的，为你选了一首歌，听着这首我给你选的歌来看这些吧~还记得我们在高中的时光吗？最初我们的认识和熟悉是怎怎样的方式呢？嘿嘿，没错，就是我舔着脸在本子上给你写下了第一句话(哦，忘了，那个时候叫小纸条)。还说不清道不明，我们的相识、相知好像都和笔与纸结下了不解之缘。我有一个习惯，就是特别相信笔纸，别看我是搞IT的，但是每当在构思网站模型或者设计数据库模型的时候，我宁愿找一支笔，拿一张纸来进行记录。我相信那些记下来的东西。石墨在纸上摩擦留下了的痕迹，哪怕在擦除，也无法彻底去除深入到纸间纤维的碳渍。所以我很愿意将我想对你说的话记录下来。</p><p>&emsp;&emsp;很早之间就想给你写一封信了，但是一直没有付出于行动，直到从昨晚到今天的吵架、冷战。我想，这算是一个契机吧。有的时候很不好意思对你说一些很认真的话，怎么说呢，你比较懂我，你应该明白我在表达什么。我在这里就不说了。</p><p>&emsp;&emsp;我们先回到昨晚的问题。没有回你消息，让你大发雷霆(是真的大发雷霆哦，把我吓惨了)，这事100%的赖我，这顿时间很慌啊，忙着写项目的，忙着面试的，忙着复习的，忙着准备考试的，关键是有时候我还提不起来力气。昨晚是在做软考的题，当时是在考试环境下，就是模拟考试，题量很多，将近百道选择题，时间也剩下的不多了，所以当时比较忙着做题，对你给我发的消息比较敷衍，心里知道你那时候有点不乐意，但是并没有解释什么，因为光那些题就让我有点焦头烂额。所以最后冷落了你。说这些不是想给自己找一些理由或者把责任堆走，而是想让你知道我最近在忙什么，昨晚上到底为什么不回你消息的原因。毕竟我知道你不喜欢我撒谎，我也不愿意只是单纯的哄你，而是想让你明确的知道我当时在做什么，让你更好的了解我。我反思了一些，当时我可以做的更好，比如提前给你说我有模拟面试并给你说明时间段；或者在你给我说的时候我简单的把自己在干嘛给你说，我相信你肯定能理解我。但是当时我并没有这样做，所以这事赖我。</p><p>&emsp;&emsp;再来说说今天的问题。今早上我冲你凶凶了，用你的话说就是不应该。但是我还是这样做了。原因我也如实给你坦白了。我承认我还是不够成熟，不够体贴，也承认有时候我心眼很小，不够大度，更承认你说我说话不算数。凶你是我的不对，无论你怎样做，凶你的那一瞬间，就是我的不对了。我在这里很认真的给你道歉，因为我知道你肯定不想听我的道歉，觉得都是假的骗你的，觉得不真诚，觉得我没有真的认识到自己的错误。选择在这里给你道歉，还有我的原因，我还是不好意思这时候对你低头(或许就是你说的大男子主义作祟)，不奢望你原谅我，但是当你看到这段话的时候，想想我特别认真的样子，应该会不那么伤心了。</p><p>&emsp;&emsp;很抱歉啊，让你伤心了，无论之前是谁的错，当我想你的那一刻开始，我就觉得我已经输了，我不想在和你争论谁对谁错这些了，因为无论你伤心还是我对了，都是我们的损失，都是我的过错。所以在写这封信的第一个字开始，我就彻底的缴械投降了，我已经是你的逃兵和俘虏了。</p><p>&emsp;&emsp;再来说说我们，从很久以前，我们就已经相识了，要是真的算算时间，已经很长了。我们一起做了很多事，比如第一次的夜不归宿，第一次的旅游，第一次的两个人计划未来，第一次的…但是每一天，我觉得都如同第一次遇见你那天，很开心，我们已经走了这么久了，也很开心，中国14亿人中能与你相遇。</p><p>&emsp;&emsp;怎么说呢，想了很久才决定给你写这封信，但是话在嘴边却有时候不知道说什么，想说的好多，什么都想对你说，但是又都不知道从何说起。不过有时候我一个人，想的最多的，还是我们的未来。我最喜欢想这些了。比如最近的，我们计划你要考华中学硕，我会想你考上以后我们的生活。比如经常在网络上搜家具设计图，想着能不能学一学室内设计，以后我们的家我想自己装修。比如我会关心很多智能家具，想着以后能不能把我们的家智能化打造，比如我还想做一做鱼缸盆景(这东西比较费钱…)，以后能不能在家里做这些…我会想很多很多我们未来的样子。想我们怎么晚上吃夜宵，想我们怎么学做菜，想我们怎么周末窝在一起刷电影，你知道我很喜欢电影，然后闲暇之余陪你看什么没听说过的韩剧啊言情剧啊什么的。我知道那样的生活还需要一段时间，但是这并不妨碍我对我们的未来的幻想。</p><p>&emsp;&emsp;还有，我很经常的听你说有的课程复习起来很吃力，总是担心自己考不上。那我在详细的说说我的故事吧。你知道的，我其实…怎么说呢…不是很喜欢课堂和学习，初一从西安回到家乡，一切很不适应，没有我熟悉的人，没有我熟悉的地方。很长时间之后我才在家乡交到了我回家之后的第一个朋友李阳和第二个朋友赵亮。李阳和我的生活很像，从深圳回来的，赵亮是“本地土著”。这是我回到家乡好几个月才交到的朋友，很是珍惜。因为我除了这两个朋友并没有其他的朋友，我们三个那个时候好的能穿一个裤子。也很感谢初中三年的他俩的陪伴。但是很遗憾，我压根学不进去。于是中考砸了，掏钱进了高中，你知道，当时一万五不是小钱，而且那时候家里刚好有些事情很困难，但是我爸还是让我上家里最好的学校。我有时候会想如果没有我爸我估计现在在哪里打工呢吧。于是我来到高中，高中前两年我还是不珍惜这机会，天天除了学习我几乎什么都做，就是不认真读书。也不知道最后我是怎么良心发现了还是突然长大了，知道要学习了，但是那个时候还有不到一年的时间。于是我拼命的学，这个时候我才知道，原来其实我并不聪明，有点笨(认真脸)，但是我不甘心。疯狂的刷题，我很骄傲的说，我一年做的题量是平常人两到三年的题量(理科题，英语没做过)，于是我这个不喜欢上学的混混稀里糊涂的上了大学。在大学我越来越觉得学习真的太重要了，几年的学习根本不够，所以我的终极目标就是活到老学到老，到死为止。这也是我非常赞成你考研究生很大的原因。给你说了一大堆，其实就是想对你说，<strong>勤能补拙，勤能补拙！</strong>我知道你有的时候压力很大，因为华中学硕并不好考，但是我还是很推荐你考，因为我相信你只要努力，一定会有机会考上的，上天不负有心人，只要肯下功夫，无论多笨，都会有机会的。当然我不是说你笨，毕竟你比我聪明多了。我就是表达这个意思。没必要很担心这些那些，凡事不要操之过急，什么都会好起来的。前行的路漫长布满荆棘，眼前的泥泞只是暂时的，还有更难行的路在前方。当历经帆，再回首，眼下的困难都是不值一提的，所以我们一起努力。</p><p>&emsp;&emsp;你是一个很棒的女孩，和你在一起，我觉得你把我改变了很多，真的太多了。你让我明白了什么是责任，什么是努力，什么是付出，什么是陪伴，什么是厮守，什么是爱。这是一封我积攒了三年的信，也是我为一天道歉的忏悔书，更是我想对你说的一些话的总结。余生很长很难走，不过身边有你，好像也不是什么困难的事情了~</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1557486269320&amp;di=03456fc0feae38c8fd28f1a5190102ca&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201702%2F28%2F20170228113116_QKM3C.thumb.224_0.jpeg" alt="img"></p><p align="right" style="margin: 0;"><b>木子李</b></p><br><p align="right"><b>2019/05/10</b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活" scheme="http://mrblog.lishanlei.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="情感" scheme="http://mrblog.lishanlei.cn/tags/%E6%83%85%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>这段时间的感悟</title>
    <link href="http://mrblog.lishanlei.cn/2019/04/15/%E8%BF%99%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E6%84%9F%E6%82%9F/"/>
    <id>http://mrblog.lishanlei.cn/2019/04/15/这段时间的感悟/</id>
    <published>2019-04-15T14:21:59.000Z</published>
    <updated>2019-04-15T19:18:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>今晚上突然想起来这段时间已经很久没有写点东西了。竟然毫无察觉。想起来当初搭建这个博客就是为了更好的记录自己，结果没过多长时间竟然忘了初衷。</p><p>先总结一些这段时间为什么没有写:</p><ol><li><p>忙着复习</p><p>还有四个月左右我就需要出去实习了，但是心中很是忐忑。一个野鸡二本大学，没有拿得出手的东西，也不是科班出身，更没有什么背景，之身前往陌生繁华的都市去寻找合适的工作。每次想到这些就很是惶恐。这段时间也是一直忙着复习：看书，刷算法等等</p></li><li><p>准备软考</p><p>去年的时候把软考初级过了，感觉难度不大，今年想着在出去之前顺便把中级证书挣到手，5月底考试，这段时间也一直在准备软考方面的东西</p></li><li><p>忙着重修</p><p>嘿，说来惭愧，重修了两科，有点丢人，这个就不说了，总之目标就是至少得把学位证和毕业证拿到手，别的不求</p></li></ol><p>对于个人的看法：</p><p>这段时间呢，基本上也和大三的离了群。自己还是适合一个人很安静的学习。我不禁对“一个人可以走的很快，一群人可以走的很远”有了新的看法：一群人不是真正的一群人处在一起，而是一群志同道合的人需要定期的交流和总结；一个人也不是真正的一个人，而是在学习的道路上只能你自己努力，其他人帮不了你。所以呢，学会忍受孤独，习惯孤独，享受孤独。不孤独，很难静下心来，至少我是这样的。</p><p>其次呢，其实我发现这段时间我总有一种感觉，就是每天都在学习，但是每天感觉时间很短暂。感觉想要干什么事情总是抽不开身。比如前端时间我的一个项目参加了挑战杯并且入围了全校赛，但是其实这个项目还是没有开始的，所以我想这几天撸一个，并且想用其他的框架写，但是光学这个框架就拖了好长时间。感觉总是没有时间。当然，现在我也认识到了，不能将自己的计划当做全部，因为生活中有很多突发性的事件。应该做的是合理做自己的个人事件，当遇到突发性的时候能够集中精力有效的解决，这本是一个很简单的道理，大一的时候我做的很好，没想到越活越倒退了。嗯，从今天下午的参加挑战杯宣讲会开始：认真做好自己该做的每一件事，不因事情的困难与否。</p><p>对于学习的看法：</p><p>现在越发觉得基础的重要性，以前总是认为有技术就好了，什么不够，技术来凑。忽略了很多基础的东西（这也是我现在压力比较大的一个原因）。所以我会很关系新的技术，会尝试玩一些新的技术，我会很看中项目能力。但是现在回过头来看看，那个时候学的技术真正精通的有多少呢？他们的底层原理和实现了解吗？你的项目中又用到了多少新的东西呢？你做的项目又有几个能够拿出手呢？这无疑是残酷的，将自己前几年的成果全盘否定，但是这也是幸运的，至少我发现的早，还有机会修正。正经的说我并不是一个科班的，大学中对自己的本专业其实不是很喜欢，要求就是拿到学位证就好了。但是既然选择了软件这条路，应该把这条路走好。前几年的经验告诉我，想要在这条路上走的远，那么基础和英语很重要的。数据结构，操作系统，计算机网络，离散数学。。。等等。加油吧，当你认识到自己的不对的时候，还来得即。也希望看到这些东西的人能够引以为戒。</p><p>其次是效率的问题。效率真的很重要，现在也是一个人在复习了，不能当一天和尚撞一天钟。没有人在旁边看着，没有人督促，自己必须得高效率的学习和做事情。如果要学习的话就需要屏蔽所有的杂念和可能会影响你的事情。比如一会想看看手机，一会想听听歌，一会想出去抽根烟解闷。应该是全神贯注的在那段时间学习。延伸到任何事情，都需要这样子做。</p><p>最后，我觉得学习不只看书，这段时间我就是在一直看书。因为有的东西啊，你得敲一敲，看看结果，或者从网络上获得更多的东西。只看书，是记不住的。应该多方位的结合。</p><p>还有一点，是关于找工作的，对于比试，一定要记录下所有的题目，下去每一道题吃透。对于面试，应该开着录音，下去一遍遍的总结自己当时答得行不行，应该怎么答，态度应该怎样，面试官的问题好好吃透，还有《剑指Offer》这本书不能只看一遍。</p><p>对于生活的看法：</p><p>越来越看中家人，爸妈真的很不容易，现在在外面上学，之后出去工作之后可能更少时间联系和见面，他们一直都是记挂这自己的。现在我能做的就是常给他们打打电话。经常聊一聊。</p><p>对于女朋友，今年暑假也准备去见家长了，先见我这边的。慢慢的都会好的。</p><p>这段时间对自己的变化挺大的，至少态度是摆正了，加油，每一步认真走，我相信什么都会越来越好的。希望看到这篇文章的人也能引以为戒。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活" scheme="http://mrblog.lishanlei.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随心而发" scheme="http://mrblog.lishanlei.cn/tags/%E9%9A%8F%E5%BF%83%E8%80%8C%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>今夜杂想</title>
    <link href="http://mrblog.lishanlei.cn/2019/03/12/2019%E5%B9%B4%E5%B1%95%E6%9C%9B/"/>
    <id>http://mrblog.lishanlei.cn/2019/03/12/2019年展望/</id>
    <published>2019-03-12T12:55:10.000Z</published>
    <updated>2019-03-12T21:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>2019年3月12日，也就是今晚，我的心情很乱，提不起一天斗志。原因是什么呢？我也在思考，可能是我还没有真正的意识到现在的紧急性吧。也可能是我的抵抗力太低，生活中很多小的事情都可以转移我的注意力。总之，几天的我，是菜鸡的一天。</p><p>先来看看我的2018年吧</p><p><strong>爱情</strong>：和她的关系增进了很多，她更紧密的走进了我，我相信我们会越来愈好。虽然在这一年里，我们的吵架次数特别多，但是总结下来，基本上都是我的问题，真是一个好的女孩，有时候我就在想，如果是我是女朋友，那早就和远远地离开这个人了。吵架是避免不了的，但是我会积极改正我的错误，争取做的更好，更少的争吵。总体来说，很是顺利。</p><p><strong>亲情</strong>：感觉很少给父母打电话，老妈不止一次的批评我了。最后规定一星期给他打一次电话。我照做了，觉得很对不起父母，唉。</p><p><strong>生活</strong>：感觉好像没有了很多情感，有时候感觉时间过得很快。或者说，不是时间，而是别的东西，比如以前可以让自己很激动的一件事情，但是放在现在的自己身上，根本一点感觉都没有，我不知道是所谓的变成了老油条还是对生活失去了动力，总之感觉就是提不起来劲。一天当中美好的日常的什么的根本觉得无所谓，所以很快就过去了。同时，对于自己的生活规律这块也变得很乱，每天晚上很晚睡，早上却很晚起，根本就是不规律的，但是每次说准备改正的时候，又狠不下心。很多方方面面的，真是不想说了。</p><p><strong>学习</strong>：2018年真是一个失败的一年，我现在恨不得大嘴巴子抽自己，怎么这么懒，怎么这么不争气，气死当初的自己了，简直就是废物一个。自我感觉学了很少的东西，很多重要的东西根本没有掌握，本来就不是一个计科科班生，还不更加努力，真是的，真想给自己一个嘴巴子长长记性。</p><p><strong>总结</strong>：失败居多，尤其是学习方面，还有个人生活规律上应该抓紧。</p><p><img src="http://img2.imgtn.bdimg.com/it/u=2222898687,1335022187&amp;fm=200&amp;gp=0.jpg" alt="img"></p><p>2019年我的目标：</p><ul><li>抽出更多的时间陪陪父母</li><li>让我和她的关系更好</li><li>把计科的知识点好好复习</li><li>刷题刷题刷题复习复习</li><li>找一个自己满意的工作</li><li>调整自己的状态，回到以前活力满满的时候</li><li>让自己的技术更上一层楼</li></ul><p>呵呵呵，一篇毫无营养毫无新意的流水账出炉。。。烦死了。。。</p><p><img src="http://img4.imgtn.bdimg.com/it/u=1917917580,1680334342&amp;fm=26&amp;gp=0.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活" scheme="http://mrblog.lishanlei.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随心而发" scheme="http://mrblog.lishanlei.cn/tags/%E9%9A%8F%E5%BF%83%E8%80%8C%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>在路上--长安</title>
    <link href="http://mrblog.lishanlei.cn/2019/03/09/%E5%9C%A8%E8%B7%AF%E4%B8%8A-%E9%95%BF%E5%AE%89/"/>
    <id>http://mrblog.lishanlei.cn/2019/03/09/在路上-长安/</id>
    <published>2019-03-09T04:01:46.000Z</published>
    <updated>2019-03-08T21:36:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>我们是很早之前就决定去一次西安的。</p><p>一来呢，我们在一起很久，但是苦于我比较忙，没有怎么带她出去走走；二来呢，我自小在西安长大，西安对我来说算是半个故乡。她想要去看看我长大的地方，我想要故地而重游，于是，第一站的目的地也就定下来了。</p><p>但是一直抽不出身来，于是这件事也就耽搁了。我们大三寒假时，我觉得还有一年就要出校门了，不能让这件事情和我们一起走出校门，哪怕在忙也要抽出身来，于是这件耽搁很长时间的事情也就重新被提起了。</p><p>首先最主要的是旅游攻略，这些事我不想让她做，怎么说呢，这家伙可爱的有点笨笨，这些操心的事情还是我来做吧。于是每天抽出一点时间上网看攻略，总结，想各种突发事情应该怎么应对，每天的日程安排，路线制定，等等。差不多花了三天的左右完成。不过很遗憾，现在找那份攻略已经不知道在哪里了。</p><p>然后是提前预定，比如住的酒店，来往车票等等。在这里我觉得做学生真好，为什么呢？？哈哈，因为学生票对于承认票来说是半价。要知道，在我的计划里要去的景点大概有十几个，所有的都是半价，为我们两个苦逼学生省下了不少钱呢。</p><p>到那里之后发现西安真的变化很大，很多地方我已经记不清了，毕竟已经离开了快十年了。不过让我有感觉的是，无论男女老少，那标准的陕西发音让我回忆起了很多。我们去的时候是冬天，本想着去西安看一看雪景，然而天宫不作美，天气是够冷了，但是雪到是一点都没有看到。</p><p>这是我们到西安之后古都长安给我们的第一个惊喜：</p><p><img src="/2019/03/09/在路上-长安/IMG_20190113_185418.jpg" alt="钟楼"></p><p>对喽，这就是大名鼎鼎的钟楼！我们住的地方离这里非常近，近道出了门就能看到这片景象。每天晚上我们乐此不疲的就是吃饭的时候从它身边经过。</p><p>对于钟鼓楼的景象还有很多：</p><p><img src="/2019/03/09/在路上-长安/IMG_20190113_190115.jpg" alt="钟楼"></p><p><img src="/2019/03/09/在路上-长安/IMG_20190114_215659.jpg" alt="钟楼"></p><p><img src="/2019/03/09/在路上-长安/IMG_20190114_194512.jpg" alt="钟楼"></p><p><img src="/2019/03/09/在路上-长安/IMG_20190113_185507.jpg" alt="钟楼"></p><p>哈哈，没错，上面的就是我和她，不过因为我的拍照技术实在不敢恭维，这张照片我只敢偷偷放出来….希望她没有看到…</p><p>要说我们去了哪些地方：钟鼓楼、回民街、小雁塔(小慈恩寺)、大雁塔(大慈恩寺)、明城墙、大唐芙蓉园、碑林博物馆….还有一些名称记不清了，毕竟决定写这篇文章的时候，距离我们去的时间已经很长了。</p><p>这是在大雁塔北广场的一个购物中心里面拍的，我觉得这个悟空好帅~</p><p><img src="/2019/03/09/在路上-长安/IMG_20190115_132700.jpg" alt="钟楼"></p><p>这是我们准备进入大慈恩寺在门口拍的：</p><p><img src="/2019/03/09/在路上-长安/IMG_20190115_134345.jpg" alt="钟楼"></p><p>大雁塔本塔：</p><p><img src="/2019/03/09/在路上-长安/IMG_20190115_134705_1.jpg" alt="钟楼"></p><p>这是我们在大雁塔脚下为它照的，据说，环绕大雁塔走一圈，会有美好的祝福，然后你就能看到两个傻子手拉手大冷天绕着大雁塔走了一圈又一圈….哈哈</p><p><img src="/2019/03/09/在路上-长安/IMG_20190115_144724.jpg" alt="钟楼"></p><p>这是我们在大雁塔最顶层拍摄的，虽然那天的天气不是很好。超喜欢这种感觉，仿佛自己穿越回了那个梦一样的大唐，置身一跃却发现自己依旧停留在当今。</p><p><img src="/2019/03/09/在路上-长安/IMG_20190115_142606.jpg" alt="钟楼"></p><p>这是永宁门，哈哈，看那个拿着票的傻子~</p><p><img src="/2019/03/09/在路上-长安/IMG_20190115_163914.jpg" alt="钟楼"></p><p>这是在城墙上拍的附近的建筑，很有感觉，值得一提的是其实永宁门和碑林博物馆离得很近。</p><p><img src="/2019/03/09/在路上-长安/IMG_20190115_170308.jpg" alt="钟楼"></p><p>在城墙上拍到的天色：</p><p><img src="/2019/03/09/在路上-长安/IMG_20190115_173511.jpg" alt="钟楼"></p><p>最后以某人的猪手镇楼：</p><p><img src="/2019/03/09/在路上-长安/IMG_20190115_171029.jpg" alt="钟楼"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="旅游" scheme="http://mrblog.lishanlei.cn/categories/%E6%97%85%E6%B8%B8/"/>
    
    
      <category term="在路上" scheme="http://mrblog.lishanlei.cn/tags/%E5%9C%A8%E8%B7%AF%E4%B8%8A/"/>
    
  </entry>
  
  <entry>
    <title>网页短链接实现原理探究</title>
    <link href="http://mrblog.lishanlei.cn/2019/03/07/%E7%BD%91%E9%A1%B5%E7%9F%AD%E9%93%BE%E6%8E%A5%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
    <id>http://mrblog.lishanlei.cn/2019/03/07/网页短链接实现原理探究/</id>
    <published>2019-03-07T05:18:43.000Z</published>
    <updated>2019-03-12T21:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>事情是这样的，今天一人问我一个问题，但是我懒得在说，就在网上找了一篇博客通过QQ发送给他，但是在发送链接时我发现之前很长的链接变成了短链接，且这个短链接能够正常访问之前的长链接，好奇之下就有了这篇文章．</p><h3 id="什么是短链接？"><a href="#什么是短链接？" class="headerlink" title="什么是短链接？"></a>什么是短链接？</h3><p>我的理解就是通过一定的算法和技术实现将原本很长的网址转换为较短的网址，从而便于用户记忆和在互联网上的传播．常用于有字数约束的微博，二维码等场景．</p><p>现在很多公司都提供了短链接服务，比如百度，新浪微博等等，以供用户自由方便的生成短链接．</p><p>短链接的大致整体流程</p><p>今天上午我找的原本链接是这个：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.wpjam.com/m/scripts-and-plugins-for-analyzing-website-traffic-stats/</span><br></pre></td></tr></table></figure><p>生成的短链接(长期的话可能会无效)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://url.cn/5r8GoSZ</span><br></pre></td></tr></table></figure><p>大致流程是这样的：我复制(输入)了一个长链接，通过腾讯服务器的转化后得到一个以<a href="http://url.cn" target="_blank" rel="noopener">http://url.cn</a> 开头的短链接，然后我可以将该网址在互联网上进行分享和传播，其他人在访问该短网址可以进入到之前原本长网址对应的页面．</p><p><img src="/2019/03/07/网页短链接实现原理探究/20180930143142269.png" alt="20180930143142269"></p><p> 所以要想将生成短链接，我们需要注意两个问题：</p><ol><li>如何将任意长的字符串转化为较短长或者固定长的字符串．</li><li>如何将短链接还原成之前的长链接，使之能够访问．</li></ol><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><h5 id="Hash实现"><a href="#Hash实现" class="headerlink" title="Hash实现"></a>Hash实现</h5><p>通过一定方式将任意长的文本转化为一个固定长的字符串，只要目标文本长度适当，那么我们对于不同的输入通过哈希几乎(注意是几乎)不可能得到对应同一个字符串．通过对长链接进行Hash运算，将Hash值作为这个长链接的唯一标示．但是通过Hash实现可能会造成碰撞．不一样的长网址缩短成了同一个短网址，那也就做不到复原了．</p><p>对于碰撞问题，有一种缓冲方法就是在呈现碰撞了以后后边在增加随机字符，随机字符的增加能够缓解碰撞的疑问，但是这终究是一种缓冲的办法，没有彻底解决碰撞．</p><h5 id="自增序列算法-永不重复算法"><a href="#自增序列算法-永不重复算法" class="headerlink" title="自增序列算法(永不重复算法)"></a>自增序列算法(永不重复算法)</h5><p>我们可以设置一个自增id，对于每一个新的长链接给他一个不重复的id．</p><p>原理：当服务器接收到一个网址时首先检验这个网址在服务器中是否再存，如果不存在，存储这个新网址并分发一个id，这个id设置成自增，保证了每一个存储的网址的id都是唯一标示．比如上面的，当一个链接过来时，给这个链接发一个0，再有一个链接过来时，给后面这个链接一个1，以此类推．</p><p>数据实现：我们发现短链接后面的参数好像都是定长的，但是如果通过id进行时，参数不定长，且随着id的自增，可能会出现这种情况：url.cn/10000000 . 我们可以将十进制的id转化为多进制，比如在以’0-9a-z’这36个字符表示的36进制中，一亿可以被表示为1njchs，基本实现不重复够用．如果数据量更大，我们可以采用62进制进行转化：</p><p><img src="/2019/03/07/网页短链接实现原理探究/20180930145801286.png" alt="20180930143142269"></p><p>短址的长度一般设为 6 位，而每一位是由 <code>[a - z, A - Z, 0 - 9]</code> 总共 62 个字母组成的，所以 6 位的话，总共会有 62^6 ~= 568亿种组合。</p><p>存储实现：</p><p>对于小型系统，简单的mysql系统的表自增索引即可实现(注意自增id数据类型，int只能到65535)</p><p>大型系统可以搭建分布式key-value系统进行存储．</p><p>我使用mysql简单建了一张表，用于保存长网址的数据，只有两个字段，一个是主键用于保存id，一个url字段用于存放原始的长网址．在进行长网址转换时，先检查数据表中是否存在该长网址，如果存在直接获取该记录的id，否在创建一条新的记录并返回该记录的id，对于这id进行进制转化处理后拼接到准备好的域名后面得到一个对应的短网址返回给用户．</p><p>这里我简单模仿了一个转换短链接的功能：</p><p>url.php：用于模拟数据库存储</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">'http://test1.com/12345vn6'</span>,</span><br><span class="line">    <span class="string">'http://test2.com/1234gf56'</span>,</span><br><span class="line">    <span class="string">'http://teat1.com/123ssgg456'</span>,</span><br><span class="line">    <span class="string">'http://test1.com/1234svss56'</span>,</span><br><span class="line">    <span class="string">'http://tefasfd1.com/123456'</span>,</span><br><span class="line">    <span class="string">'http://tesddt1.com/12sss3456'</span>,</span><br><span class="line">    <span class="string">'http://tehghdgst1.com/123dsaf456'</span>,</span><br><span class="line">    <span class="string">'http://tedddst1.com/12SDsd3456'</span>,</span><br><span class="line">    <span class="string">'http://testaa1bb.com/1234ccgfryh56'</span>,</span><br><span class="line">    <span class="string">'http://testaa1dfd.com/1234ccgfryh56'</span>,</span><br><span class="line">    <span class="string">'http://testaa1.com/1234ccgfryh56'</span>,</span><br><span class="line">    <span class="string">'http://testaa1.cssom/1234ccgfryh56'</span>,</span><br><span class="line">    <span class="string">'http://testaa1.com/1234ccgfryh56'</span>,</span><br><span class="line">    <span class="string">'http://testraa1.com/1234ccgfryzh56'</span>,</span><br><span class="line">    <span class="string">'http://teffstaa1.com/1234ccgfsryh56'</span>,</span><br><span class="line">    <span class="string">'http://testaxxa1.com/1234ccgfrsryh56'</span>,</span><br><span class="line">    <span class="string">'http://testaa1ll.com/1234ccgyrfryh56'</span>,</span><br><span class="line">    <span class="string">'http://testaa1.com/1234ccgfryyh56'</span>,</span><br><span class="line">    <span class="string">'http://tesbbtaa1.com/1ss234cjcgfryh56'</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>get.php：用于模拟生成短链接</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">require</span> <span class="string">'./jinzhi.php'</span>;</span><br><span class="line">    $arr = <span class="keyword">include</span>(<span class="string">'./url.php'</span>);</span><br><span class="line"></span><br><span class="line">    $host = <span class="string">'http://url.cn/'</span>;</span><br><span class="line"></span><br><span class="line">    $url = $_SERVER[<span class="string">'HTTP_HOST'</span>] . $_SERVER[<span class="string">'SCRIPT_NAME'</span>];</span><br><span class="line"></span><br><span class="line">    $keyId = in_array($url, $arr) ? array_search($url, $arr) : (array_push($arr, $url) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    $toKey = get_char($keyId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> $host . $toKey;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>jinzhi.php：模拟进制转化</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span>  im:十进制数转换成三十六机制数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> (int)$num 十进制数</span></span><br><span class="line"><span class="comment"> * return 返回：三十六进制数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_char</span><span class="params">($num)</span> </span>&#123;</span><br><span class="line">    $num = intval($num);</span><br><span class="line">    <span class="keyword">if</span> ($num &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    $charArr = <span class="keyword">array</span>(<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>, <span class="string">'H'</span>, <span class="string">'I'</span>, <span class="string">'J'</span>, <span class="string">'K'</span>, <span class="string">'L'</span>, <span class="string">'M'</span>, <span class="string">'N'</span>, <span class="string">'O'</span>, <span class="string">'P'</span>, <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'S'</span>, <span class="string">'T'</span>, <span class="string">'U'</span>, <span class="string">'V'</span>, <span class="string">'W'</span>, <span class="string">'X'</span>, <span class="string">'Y'</span>, <span class="string">'Z'</span>);</span><br><span class="line">    $char = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        $key = ($num - <span class="number">1</span>) % <span class="number">36</span>;</span><br><span class="line">        $char= $charArr[$key] . $char;</span><br><span class="line">        $num = floor(($num - $key) / <span class="number">36</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> ($num &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> $char;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span>  im:三十六进制数转换成十机制数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> (string)$char 三十六进制数</span></span><br><span class="line"><span class="comment"> * return 返回：十进制数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_num</span><span class="params">($char)</span></span>&#123;</span><br><span class="line">$array=<span class="keyword">array</span>(<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>,<span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>, <span class="string">"K"</span>, <span class="string">"L"</span>,<span class="string">"M"</span>, <span class="string">"N"</span>, <span class="string">"O"</span>,<span class="string">"P"</span>, <span class="string">"Q"</span>, <span class="string">"R"</span>, <span class="string">"S"</span>, <span class="string">"T"</span>, <span class="string">"U"</span>, <span class="string">"V"</span>, <span class="string">"W"</span>, <span class="string">"X"</span>, <span class="string">"Y"</span>,<span class="string">"Z"</span>);</span><br><span class="line">$len=strlen($char);</span><br><span class="line"><span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;$len;$i++)&#123;</span><br><span class="line">$index=array_search($char[$i],$array);</span><br><span class="line">$sum+=($index+<span class="number">1</span>)*pow(<span class="number">36</span>,$len-$i<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> $sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>进行路由请求：<a href="http://localhost:4000/get.php/10000000" target="_blank" rel="noopener">http://localhost:4000/get.php/10000000</a></p><p>输出：<a href="http://url.cn/J" target="_blank" rel="noopener">http://url.cn/J</a></p><p>至于解析短链接跳转至原有链接，只是对上面思路进行取反．</p><h5 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h5><p>实现思路：</p><ol><li>将长网址 <code>md5</code> 生成 32 位签名串,分为 4 段, 每段 8 个字节</li><li>对这四段循环处理, 取 8 个字节, 将他看成 16 进制串与 0x3fffffff(30位1) 与操作, 即超过 30 位的忽略处理</li><li>这 30 位分成 6 段, 每 5 位的数字作为字母表的索引取得特定字符, 依次进行获得 6 位字符串</li><li>总的 <code>md5</code> 串可以获得 4 个 6 位串,取里面的任意一个就可作为这个长 url 的短 url 地址</li></ol><p>这种算法虽然会生成四个短链接，但是存在重复几率．</p><h5 id="算法对比"><a href="#算法对比" class="headerlink" title="算法对比"></a>算法对比</h5><p>采用自增序列的好处就是简单好理解易操作．但是由于id随着增大长度不固定，但是这个问题可以通过让id从指定的数字开始递增即可以解决．还有一个问题就是我们使用的短码是有序的，可能会存在安全方面的问题．当然相关的防护手法也有很多，比如签名验证之类的安全策略；我们也可以自己实现安全手法，比如从一个随机中心值进行开端计数，然后选用一些校检位算法计算出固定位的校检码，将其连接起来，得到固定长不递增的短码．</p><p>第二种算法存在碰撞的问题，虽然产生重复(碰撞)的几率很小．但是也采用这种算法也有一个好处就是短码的位数是固定的，不会从一位到多位．</p><p>所以这两种算法各有千秋，如果事务所需要的短链接有效期较短，那么通过批处理定期清洗，那么用摘要算法也不错．而自增算法能够确保任何恳求量都不会呈现冲突也不失一种非常好的解决算法．</p><h3 id="重定向的问题-301还是302"><a href="#重定向的问题-301还是302" class="headerlink" title="重定向的问题(301还是302)"></a>重定向的问题(301还是302)</h3><p>短链接重定向的执行过程：</p><ol><li>用户访问短链接：<a href="https://dwz.cn/9WnR9Qcx" target="_blank" rel="noopener">https://dwz.cn/9WnR9Qcx</a></li><li>短链接服务器dwz.cn收到请求，根据URL路径<a href="https://dwz.cn/9WnR9Qcx" target="_blank" rel="noopener">9WnR9Qcx</a>获取到原始的长链接：<a href="http://www.lishanlei.cn/" target="_blank" rel="noopener">http://www.lishanlei.cn/</a></li><li>服务器返回状态码，将响应头中的Location设置为：<a href="http://www.lishanlei.cn/" target="_blank" rel="noopener">http://www.lishanlei.cn/</a></li><li>浏览器重新向<a href="http://www.lishanlei.cn/" target="_blank" rel="noopener">http://www.lishanlei.cn/</a>发送请求</li><li>返回响应</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Request URL: https://dwz.cn/9WnR9Qcx</span><br><span class="line">Request Method: GET</span><br><span class="line">Status Code: 302 Found</span><br><span class="line">Remote Address: 220.181.164.108:443</span><br><span class="line">Referrer Policy: no-referrer-when-downgrade</span><br><span class="line"></span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Allow-Headers: Origin,Accept,Content-Type,X-Requested-With</span><br><span class="line">Access-Control-Allow-Methods: POST,GET,PUT,PATCH,DELETE,HEAD</span><br><span class="line">Access-Control-Allow-Origin: </span><br><span class="line">Content-Length: 47</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Date: Wed, 03 Oct 2018 05:42:18 GMT</span><br><span class="line">Location: http://www.lishanlei.cn/</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>那么服务器在返回状态码时应该选取301还是302呢？</p><p>301是永久重定向，而302是临时重定向．</p><p>如果选取301，短链接生成以后就不会变化，所以用301符合http语义，这样对服务器的压力会有所减少．但是这样一来，我们就无法统计短地址被点击的次数了．</p><p>而选择302会增加服务器的压力，但是我们可以统计短链接被点击的次数，这些数据可能对于公司的发展规划非常重要．</p><p>综上所述，我认为更好的应该选择302</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="技术性" scheme="http://mrblog.lishanlei.cn/categories/%E6%8A%80%E6%9C%AF%E6%80%A7/"/>
    
    
      <category term="好奇害死猫" scheme="http://mrblog.lishanlei.cn/tags/%E5%A5%BD%E5%A5%87%E5%AE%B3%E6%AD%BB%E7%8C%AB/"/>
    
  </entry>
  
  <entry>
    <title>人是一株有思想的芦苇</title>
    <link href="http://mrblog.lishanlei.cn/2019/03/07/%E4%BA%BA%E6%98%AF%E4%B8%80%E6%A0%AA%E6%9C%89%E6%80%9D%E6%83%B3%E7%9A%84%E8%8A%A6%E8%8B%87/"/>
    <id>http://mrblog.lishanlei.cn/2019/03/07/人是一株有思想的芦苇/</id>
    <published>2019-03-07T05:18:32.000Z</published>
    <updated>2019-03-06T21:42:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>​    帕斯卡尔在他的<strong>《思想录》</strong>中曾说过这么一句话：</p><blockquote><p>人只不过是一根芦苇，是自然界最脆弱的东西，但他是一根有思想的芦苇。</p></blockquote><p>　　用不着整个宇宙都拿起武器来才能毁灭；一口气、一滴水就足以致他死命了.然而,纵使宇宙毁灭了他,人却仍然要比致他于死命的东西更高贵得多；因为他知道自己要死亡,以及宇宙对他所具有的优势,而宇宙对此却是一无所知。</p><p>​    　我始终以此话作为我的人生谨言。人体有界，国家有界，然思想无界。一个人的寿命是可以老去的，他的生命是可以被夺走的，他的记忆是可以抹去的，他的认知是可以改变的，唯独其思想无法撼动。</p><h1 id="什么是思想？"><a href="#什么是思想？" class="headerlink" title="什么是思想？"></a>什么是思想？</h1><p>​      　通常而言，一个人对事物缺乏认知和见解，我们可以说他是一个没有思想的人。但是究竟什么是思想的？？怎样才能变得有思想呢？？很久以前我就在考虑这个问题，就在今晚的一次会议上，我模糊明白了一些。</p><p>   　 在我看来，思想是是由两方面决定的：观点和内心准则。</p><p>​    　说一个人有思想，其实很多时候体现在那个人有着自己的看法观点，有自己的观点就是有思想。不要觉得这很容易，其实我们的很多观点，是通过其他人的观点来产生的，也就是说，大多数人在其之前是没有观点的。对于事物认知程度多少和自身观点的接近本质性，抽象出来就是你的思想的丰富性。</p><p>​    　其二，一个人的内心准则在我看来也是构成思想的重要一部分。内心准则和思想？感觉风马牛不相及的两个东西为什么会有关联呢？听我慢慢到来。什么是内心准则呢？我觉得其实就是一个人对于做事的标准和对外界对社会对宇宙的自己的看法。简单的说，就是一把尺子，一把衡量自身三观和外界差异的尺子。我们经常见有的人做事很有一套标准，不容易受外界的影响，我们也会觉得他很有思想。</p><p>​    　这里可能有一个认知的问题。首先，观点可能不是正确的。事实是外界确实存在或发生的，它是观点的基础，但不能说他它是观点。观点是在事实基础上加上自己的理性分析和认知所产生的，是对该事物的一种看法和理解。</p><p>​    　有时侯我们会见到一种人，他们可能有很多的知识，可能会很多技能，也可能有很多物质上的东西，但是，他们对于很多东西没有自己的观点，对于所做的事情没有一套属于自己的准则，所以他们是没有思想的。我且称他们为枯萎的芦苇。</p><p><img src="https://upload-images.jianshu.io/upload_images/4653473-2c02dc28f9ab90d9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="怎么才能变得有思想？"><a href="#怎么才能变得有思想？" class="headerlink" title="怎么才能变得有思想？"></a>怎么才能变得有思想？</h1><p>　　人不可能生来就有思想，一个人的思想是在漫长岁月中认知的积累和发酵形成的。可能会有一些天才，他们生来就有超出常人的思想，但更多的还是需要通过方法来进行形成。</p><p>​    　那么怎样才能变得有思想呢？在我看来眼光和格局决定了一个人的思想。曾经沧海难为水，除却巫山不是云。说的就是这个道理。</p><p>​    　当我还是孩童时，我认为我的学校就是世界，里面有我的一切，可能我以后都要在这里度过，上了初中后，我以为我的以后是在这座城市，这座城市里有我熟悉的一切，后来上了高中，我以为我就是局限于这个省，我觉得我这辈子都不可能走出这个省。后来我来到了大学，我走出了那个小学，我又出了那个城市，我也曾有出过那个省。在大学中，我加入了三月，这是一个非常优秀的平台，我不在将我自己局限于一个普通二本的普通学生，不在局限于不考研就得死，不在局限于像我这样的学校本科毕业生很难就业。我开始有了更多的想法，我也有了勇气去追逐属于自己的一颗星，我甚至觉得，我的未来，不应该让我这么轻易的能想到，我希望它永远是一个false，不是没有的意思，而是未知。属于我的未知的人生。我的未来应当是一片星空，这样方才能够我去施展。我的未来应该是一座险峰，这样登高望远方才酣畅淋漓。我的未来应当是一个黑洞，那么有吸引我那么美丽，充满了不定性。这是眼光的改变所带给我的。</p><p>​    　那么格局是什么呢？在我看来一个人对于自己和外物的观察能力和洞察能力组成了其对于外界的认知能力，认知能力的大小决定了这个人的认知程度，而认知程度就是一个人的格局。所谓的胸有成竹，就是一种格局。</p><p>​    　格局有何作用？苏秦因心有六国于是佩六国相印协六国逼秦废帝，张仪心有山河，以片言得楚六百里，毛泽东正因看到当时局势，于是便有了恰同学少年。此为格局之用。</p><p>​    　一个人唯有看的深看的远看的多，唯有胸中有沟壑，胸中有千山，放才能提升自己的思想，使自己不在局限于些许得失或是一丘一壑。</p><p>​    　人是要有自己的思想的，其思想的丰富性很大程度上体现了一个人的以后的成就，为什么这么说呢？其实看看很多大公司的老总我们就明白了，譬如乔布斯，在小灵通和诺基亚平板机称霸天下的时候他敏锐发现了智能手机的未来，于是便有了被上帝咬了一口的苹果。譬如马云，在几十年前互联网浪潮还没有席卷中国的时候，他看出了互联网经济的巨大利润，于是有了阿里巴巴。这样的例子数不胜数，有思想不一定能够有美好的未来，但是没有思想一定没有成功的未来。</p><p><img src="https://upload-images.jianshu.io/upload_images/4653473-a9b0ae0817f4ee46.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>​    很想说说今天开会的一些感触，可能比较乱。</p><p>​    永远不要被自己感动，因为有人比你更努力。我觉得，认为自己非常努力的人，其实恰恰是不努力的那个，你只看到了自己的些许努力，却没有看到别人的疯狂。</p><p>​    当下自己所处的环境不好，不能决定你的未来，这更是我们需要努力的理由，努力提升，努力改变。</p><p>​    人生最无力的时候，就是明明已经做好了全力冲刺的准备，却发现根本没有参加比赛的资格。心之所悲，无外如是。如果现在还在找着一些理由麻痹自己那么到时侯真的练成功资格都没有。</p><p>​    人生应该像一座山，为什么我们要这么努力的爬向山顶呢？因为在山顶，我们能看到很远很远很远的天地，而在山脚，我们只能看到模糊的山顶。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活" scheme="http://mrblog.lishanlei.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="个人感想" scheme="http://mrblog.lishanlei.cn/tags/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>代码审查如何做</title>
    <link href="http://mrblog.lishanlei.cn/2019/03/07/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5%E5%A6%82%E4%BD%95%E5%81%9A/"/>
    <id>http://mrblog.lishanlei.cn/2019/03/07/代码审查如何做/</id>
    <published>2019-03-07T05:18:00.000Z</published>
    <updated>2019-03-06T21:39:34.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="做-Code-Review-的正反方观点"><a href="#做-Code-Review-的正反方观点" class="headerlink" title="做 Code Review 的正反方观点"></a>做 Code Review 的正反方观点</h1><p>首先，我们先来看看正方的观点：</p><ol><li>Code review 中，可以通过大家的建议增进代码的质量。</li><li>Code review 是一个传递知识的手段，可以让其它并不熟悉代码的人知道作者的意图和想法，从而可以在以后轻松维护代码。</li><li>Code review 鼓励程序员们相互学习对方的长处和优点。</li><li>Code review 可以被用来确认自己的设计和实现是清楚和简单的。</li></ol><p>我们再来听下反方的声音:</p><p>很多开发Team抱怨Code Review就是一个形式，费时费力不说，发现的问题还不如测试，而评审者们除了在代码风格上有些见术，别的也就没什么用了，长而久之，大家都会开始厌烦这个事了。</p><p>那么为了这篇文章能够写下去, 笔者显然是属于正方了, 此处不再做争辩.</p><h1 id="Review时-什么该关注-什么不该关注"><a href="#Review时-什么该关注-什么不该关注" class="headerlink" title="Review时, 什么该关注, 什么不该关注"></a>Review时, 什么该关注, 什么不该关注</h1><p>在上面的Code Reivew中的正方观点中，我们没有提到可以帮助找到程序的bug和保证代码风格和编码标准, 那么是说Code Review不能帮助改善这几方面吗? 不是的, 这里确切地说, Code Review不是万能的, 在执行的时候, 应该专注于它应该关注的部分, 那么问题来了, Code Review时, 哪些是该关注的, 哪些又是不该关注的呢?</p><h2 id="Code-Review-时不该关注的"><a href="#Code-Review-时不该关注的" class="headerlink" title="Code Review 时不该关注的"></a>Code Review 时不该关注的</h2><p>首先, 先列几个不该在Code Review时关注的</p><ol><li>Code review <strong>不应该</strong>承担发现代码错误的职责。Code Review主要是审核代码的质量，如可读性，可维护性，以及程序的逻辑和对需求和设计的实现。代码中的bug和错误应该由单元测试，功能测试，性能测试，回归测试来保证的（其中主要是单元测试，因为那是最接近Bug，也是Bug没有扩散的地方）</li><li>Code review <strong>不应该</strong>成为保证代码风格和编码标准的手段。编码风格和代码规范都属于死的东西，每个程序员在把自己的代码提交团队Review的时候，代码就应该是符合规范的，这是默认值，属于每个人自己的事情，不应该交由团队来完成，否则只会浪费大家本来就不够的时间。</li></ol><p><strong>注意: 这里说在Code Review时不该关注, 并不是说不重要, 而是说, 这些部分应该有其他方式(例如自动化工具)去保障, 因为人的成本是最高的, 机器和程序才是便宜的.</strong></p><h2 id="Code-Review-时该关注的"><a href="#Code-Review-时该关注的" class="headerlink" title="Code Review 时该关注的"></a>Code Review 时该关注的</h2><p>代码审查者在审查代码时有非常多的东西需要关注。一个团队需要明确对于自己的项目哪些点是重要的，并不断在审查中就这些点进行检查。</p><h3 id="1-体系结构和代码设计"><a href="#1-体系结构和代码设计" class="headerlink" title="1. 体系结构和代码设计"></a><strong>1. 体系结构和代码设计</strong></h3><ul><li>代码复用: 根据“三振法”, 如果代码被复制一次，虽然不喜欢这种方式，但通常没什么问题。但如果再一次被复制，就应该通过提取公共的部分来重构它。</li><li>用更好的代码: 如果在一块混乱的代码做修改，添加几行代码也许更容易，但建议更进一步，用比原来更好的代码。</li><li>潜在的bugs: 是否会引起的其他错误？循环是否以我们期望的方式终止？</li><li>错误处理: 错误确定被优雅的修改？会导致其他错误？如果这样，修改是否有用？</li><li>效率: 如果代码中包含算法，这种算法是否是高效？ 例如，在字典中使用迭代，遍历一个期望的值，这是一种低效的方式。</li><li>新代码与全局的架构是否保持一致？</li><li>基础代码是否有结合使用了一些标准或设计样式，新的代码是否遵循当前的规范？代码是否正确迁移，或参照了因不规范而淘汰的旧代码？</li><li>代码的位置是否正确？比如涉及订单的新代码是否在订单服务相关的位置？</li><li>新代码是否重用了现存的代码？新代码是否可以被现有代码重用？新代码是否有重复代码？如果是的话，是否应该重构成一个更可被重用的模式，还是当前还可以接受？</li><li>新代码是否被过度设计了？是否引入现在还不需要的重用设计？</li></ul><h3 id="2-可读性和可维护性"><a href="#2-可读性和可维护性" class="headerlink" title="2. 可读性和可维护性"></a><strong>2. 可读性和可维护性</strong></h3><ul><li>字段、变量、参数、方法、类的命名是否真实反映它们所代表的事物, 是否能够望文生义?</li><li>是否可以通过读代码理解它做了什么？</li><li>是否理解测试用例测了什么？</li><li>测试是否很好地覆盖了用例的各种情况？它们是否覆盖了正常和异常用例？是否有忽略的情况？</li><li>错误信息是否可被理解？ log打的是否正确和足够?</li><li>不清晰的代码是否被文档、注释或容易理解的测试用例所覆盖？具体可以根据团队自身的喜好决定使用哪种方式。</li></ul><h3 id="3-功能"><a href="#3-功能" class="headerlink" title="3. 功能"></a><strong>3. 功能</strong></h3><ul><li>代码是否真的达到了预期的目标？如果有自动化测试来确保代码的正确性，测试的代码是否真的可以验证代码达到了协定的需求？</li><li>代码看上去是否包含不明显的bug，比如使用错误的变量进行检查，或误把and写成or？</li><li>作者是否需要创建公共文档或修改现存的帮助文档？</li><li>是否检查了面向用户的信息的正确性？</li><li>是否有会在生产环境中导致应用停止运行的明显错误？代码是否会错误地指向测试数据库，是否存在应在真实服务中移除的硬编码的stub代码？</li><li>你对性能的需求是什么，你是否考虑了安全问题？</li></ul><ol><li>这个新增或修复的功能是否会反向影响到现存的性能测试结果</li><li>外部调用很昂贵(a. 数据库调用. b. 不必要的远程调用. c. 移动或穿戴设备过频繁地调用后端程序)</li></ol><h3 id="4-安全"><a href="#4-安全" class="headerlink" title="4. 安全"></a><strong>4. 安全</strong></h3><ul><li>检查是否新的路径和服务需要认证</li><li>数据是否需要加密</li><li>密码是否被很好地控制？</li></ul><blockquote><p>这里的密码包含密码（如用户密码、数据库密码或其他系统的密码）、秘钥、令牌等等。这些永远不应该存放在会提交到源码控制系统的代码或配置文件中，有其他方式管理这些密码，例如通过密码服务器（secret server）。当审查代码时，要确保这些密码不会悄悄进入你的版本控制系统中</p></blockquote><ul><li>代码的运行是否应该被日志记录或监控？是否正确地使用？</li></ul><blockquote><p>日志和监控需求因各个项目而不同，一些需要合规，一些拥有比别人严格的行为、事件日志规范。如果你有规章规定哪些需要记录日志，何时、如何记录，那么作为代码审查者你应该检查提交的代码是否满足要求。如果你没有固定的规章，那么就考虑：</p></blockquote><ul><li>代码是否改变了数据（如增删改操作）？是否应该记录由谁何时改变了什么？</li><li>代码是否涉及关键性能的部分？是否应该在性能监控系统中记录开始时间和结束时间？</li><li>每条日志的日志等级是否恰当？一个好的经验法则是“ERROR”触发一个提示发送到某处，如果你不想这些消息在凌晨3点叫醒谁，那么就将之降级为“INFO”或“DEBUG”。当在循环中或一条数据可能产生多条输出的情况下，一般不需要将它们记录到生产日志文件中，它们更应该被放在“DEBUG”级别。</li></ul><h3 id="5-其他方面"><a href="#5-其他方面" class="headerlink" title="5. 其他方面"></a><strong>5. 其他方面</strong></h3><ul><li>是否合理地释放了资源</li></ul><ol><li>是否存在内存泄漏?</li><li>是否存在内存无限增长? 例如, 如果审查者看到不断有变量被追加到list或map中, 那么就要考虑下这个list或map什么时候失效, 或清除无用数据</li><li>代码是否及时关闭了连接或数据流?</li><li>资源池配置是否是否正确? 有没有过大或者过小?</li></ol><p>异常情况是否能够正确处理?</p><ol><li>超时是否能够正确处理?</li><li>调用接口出错的时候, 是否有出错处理逻辑, 并且处理正确?</li><li>进程意外重启后, 是否能够恢复到崩溃前的环境?</li></ol><p>正确性(主要与多线程环境关系密切)</p><ol><li>代码是否使用了正确的适合多线程的数据结构</li><li>代码是否存在竞态条件（race conditions）？多线程环境中代码非常容易造成不明显的竞态条件。作为审查者，可以查看不是原子操作的get和set</li><li>代码是否正确使用锁？和竞态条件相关，作为审查者你应该检查被审代码是否允许多个线程修改变量导致程序崩溃。代码可能需要同步、锁、原子变量来对代码块进行控制</li><li>代码的性能测试是否有价值？很容易将小型的性能测试代码写得很糟糕，或者使用不能代表生产环境数据的测试数据，这样只会得到错误的结果</li><li>缓存：虽然缓存是一种能防止过多高消耗请求的方式，但其本身也存在一些挑战。如果审查的代码使用了缓存，你应该关注一些常见的问题，如，不正确的缓存失效方式</li></ol><p>代码级优化, 对大部分并不是要构建低延时应用的机构来说，代码级优化往往是过早优化，所以首先要知道代码级优化是否必要</p><ol><li>代码是否在不需要的地方使用同步或锁操作？如果代码始终运行在单线程中，锁往往是不必要的</li><li>代码是否可以使用原子变量替代锁或同步操作？</li><li>代码是否使用了不必要的线程安全的数据结构？比如是否可以使用ArrayList替代Vector？</li><li>代码是否在通用的操作中使用了低性能的数据结构？如在经常需要查找某个特定元素的地方使用链表</li><li>代码是否可以使用懒加载并从中获得性能提升？</li><li>条件判断语句或其他逻辑是否可以将最高效的求值语句放在前面来使其他语句短路？</li><li>代码是否存在许多字符串格式化？是否有方法可以使之更高效？</li><li>日志语句是否使用了字符串格式化？是否先使用条件判断语句校验了日志等级，或使用延迟求值？</li></ol><h1 id="Code-Review-的实际操作建议"><a href="#Code-Review-的实际操作建议" class="headerlink" title="Code Review 的实际操作建议"></a>Code Review 的实际操作建议</h1><ol><li>代码审查是应该在互相沟通中进行讨论的，而不是相互对抗。预先确定哪些是要点哪些不是，可以减少冲突并拟定预期。</li><li>经常进行Code Review, 不要攒了1w行才让同事帮你review, 这是坑队友.</li></ol><blockquote><ul><li>要Review的代码越多，那么要重构，重写的代码就会越多。而越不被程序作者接受的建议也会越多，唾沫口水战也会越多。</li><li>程序员代码写得时候越长，程序员就会在代码中加入越来越多的个人的东西。 程序员最大的问题就是“自负”，无论什么时候，什么情况下，有太多的机会会让这种“自负”澎涨开来，并开始影响团队影响整个项目，以至于听不见别人的建议，从而让Code Review变成了口水战。</li><li>越接近软件发布的最终期限，代码也就不能改得太多。</li></ul></blockquote><p>Code Review不要太正式，而且要短</p><p>尽可能的让不同的人Reivew你的代码(不要超过3个人)</p><blockquote><ul><li>从不同的方向评审代码总是好的。</li><li>会有更多的人帮你在日后维护你的代码。</li><li>这也是一个增加团队凝聚力的方法。</li></ul></blockquote><p>保持积极的正面的态度</p><blockquote><p>无论是代码作者，还是评审者，都需要一种积极向上的正面的态度，作者需要能够虚心接受别人的建议，因为别人的建议是为了让你做得更好；评审者也需要以一种积极的正面的态度向作者提意见，因为那是和你在一个战壕里的战友。记住，你不是一段代码，你是一个人！</p></blockquote><p>学会享受Code Reivew</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ol><li><a href="https://my.oschina.net/wolx/blog/508549" target="_blank" rel="noopener">Code Review最佳实践</a></li><li><a href="http://coolshell.cn/articles/1302.html" target="_blank" rel="noopener">Code Review中的几个提示</a></li><li><a href="http://www.infoq.com/cn/articles/effective-code-reviews" target="_blank" rel="noopener">如何使代码审查更高效</a></li><li><a href="https://book.douban.com/subject/1951158/" target="_blank" rel="noopener">&lt;&lt;代码大全&gt;&gt;</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="技术性" scheme="http://mrblog.lishanlei.cn/categories/%E6%8A%80%E6%9C%AF%E6%80%A7/"/>
    
    
      <category term="审查" scheme="http://mrblog.lishanlei.cn/tags/%E5%AE%A1%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>关于本博客</title>
    <link href="http://mrblog.lishanlei.cn/2019/03/06/%E5%85%B3%E4%BA%8E%E6%9C%AC%E5%8D%9A%E5%AE%A2/"/>
    <id>http://mrblog.lishanlei.cn/2019/03/06/关于本博客/</id>
    <published>2019-03-06T11:53:44.000Z</published>
    <updated>2019-03-07T00:17:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h5 id="关于本博客"><a href="#关于本博客" class="headerlink" title="关于本博客"></a>关于本博客</h5><p>​    想要搭建博客很长时间了，期间也经历了一些历程。</p><p>​    最早使用的是自己考核写的例子，实现的是laravel5.4+blade模板写的，虽然基本功能都有，但是不得不承认，写的太粗糙了，页面交互效果……没办法说。并且那个时候没有自己的云服务器，只能在本地保存浏览。</p><p>​    后来使用了第三方的博客网站，比如CSDN，博客园，掘金，简书等等，虽然这些平台很棒，也在平台上写了很长时间，但是心里还是放不下自己的个人博客。</p><p>​    曾经也尝试再重新写一个自己的个人博客，但是中间因为种种，没有继续做下去，当时想的是用的东西都是自己用过的东西，写着没意思，学不到什么，如果因为这个事情浪费很多时间岂不得不偿失。</p><p>​    后来在github还有码云上看到别人写的个人博客项目，找了其中几个进行对比，然后选中一个，看注释，改源码，自己又买了服务器，域名，搭建起自己的博客。但是没有在上面怎么写过。后来因为疏忽云服务器被销毁了，搭建的项目也就没有了，其实那个时候并不觉得可惜，因为毕竟不是自己写的东西，只是做了少许改动；同时因为别人的始终是别人的，不能百分百的达到我心中的要求。</p><p>​    在之后，尝试过使用博客框架<strong>WordPress</strong>来搭建自己的博客，但是怎么说呢，觉得太重了，并且操作上没有达到我心中的要求，于是也就放弃了。</p><p>​    后来在翻学长们的博客的时候，看到了其中一个学长搭建的博客(在我的博客的友情链接可以看到)，觉得心中一直没有灭的火焰又燃烧了，通过它的文章了解到hexo+github pages来搭建博客，于是自己翻文档，选主题，用了一天半的时间把这个博客搭建起来了，很感谢这个学长，虽然他不知道……</p><p>​    通过在搭建过程中，真心觉得自己遇到对的了，很简单的傻瓜式搭建，可能遇到一些代码上的修改也不是什么大问题，网上的教程也很多。不像自己开发的博客项目，考虑维护啊，增加功能啊，而忽视了博客系统的本质就是用来写博客的。hexo更让我关注到博客本身而不是一系列的其他问题，真心不错！</p><p>​    博客到这里也就搭建的差不多了，我会抽时间将之前的博客同步至此。</p><h5 id="关于本人"><a href="#关于本人" class="headerlink" title="关于本人"></a>关于本人</h5><p>​    现在在读一个名不经传的学校的名不经传的大学生，非计算机专业的计算机人，尝试简单生活，高效工作，极简至上。</p><p>​    喜欢计算机，喜欢code。</p><p>​    欢迎大家和我交流。</p><p>##### </p><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="生活" scheme="http://mrblog.lishanlei.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="个人随笔" scheme="http://mrblog.lishanlei.cn/tags/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
